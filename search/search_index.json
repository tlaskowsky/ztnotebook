{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Your ZT Lab Documentation","text":"<p>This site contains documentation for various lab notebooks. Use the navigation menu to explore the labs.</p>"},{"location":"Cleanup_Lab/","title":"Cleanup_Lab","text":""},{"location":"Cleanup_Lab/#this-will-delete-all-resources-created-in-the-lab","title":"This will delete all resources created in the lab","text":"<p>Use with caution</p> <pre><code>import boto3\nimport time\nimport botocore\n\n# Initialize AWS clients\nec2 = boto3.client('ec2')\nlambda_client = boto3.client('lambda')\napigateway = boto3.client('apigateway')\niam = boto3.client('iam')\n\ndef wait_for_deletion(resource_type, resource_id, check_function):\n    print(f\"Confirming deletion of {resource_type} {resource_id}...\")\n    max_attempts = 30\n    for _ in range(max_attempts):\n        try:\n            if not check_function(resource_id):\n                print(f\"{resource_type} {resource_id} has been deleted.\")\n                return True\n        except botocore.exceptions.ClientError as e:\n            if e.response['Error']['Code'] == 'InvalidVpcID.NotFound':\n                print(f\"{resource_type} {resource_id} has been deleted.\")\n                return True\n        print(f\"{resource_type} {resource_id} is still being deleted. Waiting...\")\n        time.sleep(10)\n    print(f\"Timeout waiting for {resource_type} {resource_id} to be deleted.\")\n    return False\n\n\ndef delete_ec2_instances():\n    print(\"Deleting EC2 instances...\")\n    response = ec2.describe_instances(\n        Filters=[{'Name': 'instance-state-name', 'Values': ['pending', 'running', 'stopping', 'stopped']}]\n    )\n    instance_ids = [instance['InstanceId'] for reservation in response['Reservations'] for instance in reservation['Instances']]\n    if instance_ids:\n        ec2.terminate_instances(InstanceIds=instance_ids)\n        waiter = ec2.get_waiter('instance_terminated')\n        waiter.wait(InstanceIds=instance_ids)\n    print(\"EC2 instances deleted.\")\n\ndef delete_security_groups():\n    print(\"Deleting security groups...\")\n    response = ec2.describe_security_groups()\n    for sg in response['SecurityGroups']:\n        if sg['GroupName'] != 'default':\n            try:\n                ec2.delete_security_group(GroupId=sg['GroupId'])\n                print(f\"Security group {sg['GroupId']} deleted.\")\n            except botocore.exceptions.ClientError as e:\n                print(f\"Error deleting security group {sg['GroupId']}: {e}\")\n    print(\"Security group deletion attempted.\")\n\ndef delete_nat_gateway():\n    print(\"Deleting NAT Gateways...\")\n    response = ec2.describe_nat_gateways()\n    for nat_gateway in response['NatGateways']:\n        ec2.delete_nat_gateway(NatGatewayId=nat_gateway['NatGatewayId'])\n        wait_for_deletion('NAT Gateway', nat_gateway['NatGatewayId'], \n                          lambda id: ec2.describe_nat_gateways(NatGatewayIds=[id])['NatGateways'][0]['State'] != 'deleted')\n\n    # Release Elastic IPs\n    response = ec2.describe_addresses()\n    for eip in response['Addresses']:\n        if 'AssociationId' not in eip:\n            ec2.release_address(AllocationId=eip['AllocationId'])\n    print(\"NAT Gateways deleted and Elastic IPs released.\")\n\ndef delete_internet_gateway():\n    print(\"Deleting Internet Gateways...\")\n    response = ec2.describe_internet_gateways()\n    for igw in response['InternetGateways']:\n        if igw['Attachments']:\n            ec2.detach_internet_gateway(InternetGatewayId=igw['InternetGatewayId'], VpcId=igw['Attachments'][0]['VpcId'])\n        ec2.delete_internet_gateway(InternetGatewayId=igw['InternetGatewayId'])\n    print(\"Internet Gateways deleted.\")\n\ndef delete_subnets():\n    print(\"Deleting subnets...\")\n    response = ec2.describe_subnets()\n    for subnet in response['Subnets']:\n        if not subnet['DefaultForAz']:\n            ec2.delete_subnet(SubnetId=subnet['SubnetId'])\n    print(\"Subnets deleted.\")\n\ndef delete_route_tables():\n    print(\"Deleting route tables...\")\n    response = ec2.describe_route_tables()\n    for rt in response['RouteTables']:\n        if not rt.get('Associations') or not any(assoc.get('Main') for assoc in rt.get('Associations')):\n            ec2.delete_route_table(RouteTableId=rt['RouteTableId'])\n    print(\"Route tables deleted.\")\n\ndef delete_vpc():\n    print(\"Deleting VPCs...\")\n    response = ec2.describe_vpcs()\n    for vpc in response['Vpcs']:\n        if not vpc['IsDefault']:\n            try:\n                print(f\"Attempting to delete VPC {vpc['VpcId']}...\")\n                ec2.delete_vpc(VpcId=vpc['VpcId'])\n                wait_for_deletion('VPC', vpc['VpcId'], \n                                  lambda id: bool(ec2.describe_vpcs(VpcIds=[id])['Vpcs']))\n            except botocore.exceptions.ClientError as e:\n                if e.response['Error']['Code'] == 'InvalidVpcID.NotFound':\n                    print(f\"VPC {vpc['VpcId']} has already been deleted.\")\n                else:\n                    print(f\"Error deleting VPC {vpc['VpcId']}: {e}\")\n                    print(\"Please check and manually delete any remaining resources in this VPC.\")\n    print(\"VPC deletion completed.\")\n\n\ndef delete_lambda_function():\n    print(\"Deleting Lambda functions...\")\n    lambda_functions = lambda_client.list_functions()\n    for function in lambda_functions['Functions']:\n        if function['FunctionName'].startswith('IdentityProviderFunction-'):\n            lambda_client.delete_function(FunctionName=function['FunctionName'])\n    print(\"Lambda functions deleted.\")\n\ndef delete_api_gateway():\n    print(\"Deleting API Gateway...\")\n    apis = apigateway.get_rest_apis()\n    for api in apis['items']:\n        if api['name'] == 'IdentityProviderApi':\n            apigateway.delete_rest_api(restApiId=api['id'])\n    print(\"API Gateway deleted.\")\n\ndef delete_iam_role():\n    print(\"Deleting IAM roles...\")\n    roles = iam.list_roles()\n    for role in roles['Roles']:\n        if role['RoleName'].startswith('LabLambdaExecutionRole-'):\n            attached_policies = iam.list_attached_role_policies(RoleName=role['RoleName'])\n            for policy in attached_policies['AttachedPolicies']:\n                iam.detach_role_policy(RoleName=role['RoleName'], PolicyArn=policy['PolicyArn'])\n            iam.delete_role(RoleName=role['RoleName'])\n    print(\"IAM roles deleted.\")\n\ndef cleanup():\n    delete_ec2_instances()\n    delete_nat_gateway()\n    delete_internet_gateway()\n    delete_subnets()\n    delete_route_tables()\n    delete_security_groups()\n    delete_vpc()\n    delete_lambda_function()\n    delete_api_gateway()\n    delete_iam_role()\n    print(\"Cleanup completed.\")\n\n# Run the cleanup\ncleanup()\n\n</code></pre> <pre><code>\n</code></pre>"},{"location":"Introduction_to_Jupyter_Notebooks/","title":"Introduction to Jupyter Notebooks","text":"<p>Welcome to this introductory guide to Jupyter Notebooks! This notebook will help you get familiar with the basic operations and best practices for using Jupyter Notebooks in our lab sessions.</p>"},{"location":"Introduction_to_Jupyter_Notebooks/#1-understanding-cells","title":"1. Understanding Cells","text":"<p>Jupyter Notebooks are composed of cells. There are two main types of cells:</p> <ol> <li>Markdown cells: For text, like this one.</li> <li>Code cells: For executing Python code.</li> </ol> <p>To change a cell type, use the dropdown menu in the toolbar that says \"Code\" or \"Markdown\".</p>"},{"location":"Introduction_to_Jupyter_Notebooks/#2-running-cells","title":"2. Running Cells","text":"<p>Let's practice running cells:</p> <pre><code># This is a code cell. Click on it and press Shift+Enter to run it.\nprint(\"Hello, Jupyter!\")\n</code></pre> <p>Now, try running the cell above by clicking on it and pressing Shift+Enter.</p>"},{"location":"Introduction_to_Jupyter_Notebooks/#3-order-of-execution","title":"3. Order of Execution","text":"<p>Cells can be run in any order, but this can sometimes lead to unexpected results. It's generally best to run cells from top to bottom.</p> <pre><code># Run this cell first\nx = 5\n</code></pre> <pre><code># Then run this cell\nprint(f\"The value of x is {x}\")\n</code></pre> <p>Try running these cells in different orders and see what happens!</p>"},{"location":"Introduction_to_Jupyter_Notebooks/#4-waiting-for-cell-execution","title":"4. Waiting for Cell Execution","text":"<p>Some cells may take longer to run, especially when working with large datasets or complex computations. Let's simulate a long-running cell:</p> <pre><code>import time\n\nprint(\"Starting a long process...\")\ntime.sleep(5)  # This will pause for 5 seconds\nprint(\"Process completed!\")\n</code></pre> <p>When you run this cell, you'll see a <code>[*]</code> appear to the left of the cell, indicating that it's still running. Wait for it to complete before moving on.</p>"},{"location":"Introduction_to_Jupyter_Notebooks/#5-restarting-the-kernel","title":"5. Restarting the Kernel","text":"<p>Sometimes you may need to restart the kernel, which clears all variables and starts fresh. To do this:</p> <ol> <li>Click on the \"Kernel\" menu at the top of the notebook.</li> <li>Select \"Restart &amp; Clear Output\" or \"Restart &amp; Run All\" depending on your needs.</li> </ol> <p>Try restarting the kernel now and then re-run the cells above.</p>"},{"location":"Introduction_to_Jupyter_Notebooks/#6-best-practices","title":"6. Best Practices","text":"<ul> <li>Run cells in order: Generally, run your notebook from top to bottom to ensure all necessary variables and functions are defined.</li> <li>Don't repeatedly click \"Run\": If a cell is taking a long time, be patient. Repeatedly clicking run can queue up multiple executions.</li> <li>Clear outputs when sharing: If you're sharing your notebook, it's often good to clear all outputs first (Cell &gt; All Output &gt; Clear).</li> <li>Use Markdown for explanations: Use Markdown cells to explain your code and provide context.</li> </ul> <p>Markdown Format</p>"},{"location":"Introduction_to_Jupyter_Notebooks/#7-saving-your-work","title":"7. Saving Your Work","text":"<p>Jupyter automatically saves your work, but it's a good habit to manually save occasionally:</p> <ul> <li>Use Ctrl+S (Windows/Linux) or Cmd+S (Mac) to save.</li> <li>Or click File &gt; Save and Checkpoint.</li> </ul>"},{"location":"Introduction_to_Jupyter_Notebooks/#conclusion","title":"Conclusion","text":"<p>You've now learned the basics of working with Jupyter Notebooks! In our upcoming labs, you'll be using these skills to run pre-written code and examine results. Remember, if you ever get stuck, you can always restart the kernel and run all cells from the beginning.</p> <p>Happy learning!</p>"},{"location":"lab1/zt-lab1/","title":"Unsecured System","text":""},{"location":"lab1/zt-lab1/#lab-1-creating-an-unsecured-system","title":"Lab 1: Creating an Unsecured System","text":""},{"location":"lab1/zt-lab1/#introduction","title":"Introduction","text":"<p>Welcome to the first lab of our Zero Trust course! In this lab, we'll set up a basic, unsecured system in AWS using AWS CLI commands and Python (boto3). This hands-on approach will help you understand each component of the system and why better security practices are necessary.</p>"},{"location":"lab1/zt-lab1/#objectives","title":"Objectives","text":"<p>By the end of this lab, you will: 1. Create a Virtual Private Cloud (VPC) with a public subnet 2. Set up an Internet Gateway and configure routing 3. Create a security group with unrestricted access 4. Deploy a \"sensitive\" backend server 5. Launch a public-facing web server</p> <p></p>"},{"location":"lab1/zt-lab1/#setup","title":"Setup","text":"<p>First, let's set up our AWS environment. Make sure you have configured your AWS CLI with the appropriate credentials.</p> <pre><code># Import necessary AWS SDK and utility modules\n\nimport boto3\nimport json\nimport time\n</code></pre>"},{"location":"lab1/zt-lab1/#set-the-aws-region","title":"Set the AWS region","text":"<p>Configure the AWS region to create the network and servers</p> <pre><code># Set the AWS region for resource creation (change as needed)\n\nregion = 'us-west-2'\n</code></pre>"},{"location":"lab1/zt-lab1/#initialize-aws-clients","title":"Initialize AWS clients","text":"<p>Setup the necessary environment variables</p> <pre><code># Initialize EC2 client and resource objects for interacting with AWS\n\nec2_client = boto3.client('ec2', region_name=region)\nec2_resource = boto3.resource('ec2', region_name=region)\n\nprint(f\"AWS environment initialized in region: {region}\")\n</code></pre>"},{"location":"lab1/zt-lab1/#step-1-create-a-vpc-and-subnet","title":"Step 1: Create a VPC and Subnet","text":"<p>Let's start by creating our Virtual Private Cloud (VPC) and a public subnet.</p> <pre><code># Create VPC\n\nvpc_response = ec2_client.create_vpc(CidrBlock='10.0.0.0/16')\nvpc_id = vpc_response['Vpc']['VpcId']\nec2_client.create_tags(Resources=[vpc_id], Tags=[{'Key': 'Name', 'Value': 'UnsecuredVPC'}])\nprint(f\"VPC created with ID: {vpc_id}\")\n</code></pre>"},{"location":"lab1/zt-lab1/#access-the-vpc-service-vpc-menu-in-aws-management-console","title":"Access the VPC Service VPC Menu in AWS Management Console.","text":""},{"location":"lab1/zt-lab1/#it-should-look-like-below","title":"It should look like below:","text":"<pre><code># Create public subnet\n\nsubnet_response = ec2_client.create_subnet(VpcId=vpc_id, CidrBlock='10.0.1.0/24')\nsubnet_id = subnet_response['Subnet']['SubnetId']\nec2_client.create_tags(Resources=[subnet_id], Tags=[{'Key': 'Name', 'Value': 'PublicSubnet'}])\nprint(f\"Public subnet created with ID: {subnet_id}\")\n</code></pre>"},{"location":"lab1/zt-lab1/#access-the-vpc-service-subnets-menu-in-aws-management-console","title":"Access the VPC Service Subnets Menu in AWS Management Console.","text":""},{"location":"lab1/zt-lab1/#it-should-look-like-below_1","title":"It should look like below:","text":""},{"location":"lab1/zt-lab1/#step-2-set-up-internet-gateway-and-routing","title":"Step 2: Set up Internet Gateway and Routing","text":"<p>Now, let's create an Internet Gateway and set up the routing table.</p> <pre><code># Create Internet Gateway\n\nigw_name = \"UnsecuredIGW\"\nigw_response = ec2_client.create_internet_gateway(\n    TagSpecifications=[\n        {\n            'ResourceType': 'internet-gateway',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': igw_name\n                }\n            ]\n        }\n    ]\n)\nigw_id = igw_response['InternetGateway']['InternetGatewayId']\nec2_client.attach_internet_gateway(InternetGatewayId=igw_id, VpcId=vpc_id)\nprint(f\"Internet Gateway '{igw_name}' created and attached with ID: {igw_id}\")\n</code></pre>"},{"location":"lab1/zt-lab1/#access-the-vpc-service-internet-gateways-menu-in-aws-management-console","title":"Access the VPC Service Internet Gateways Menu in AWS Management Console.","text":""},{"location":"lab1/zt-lab1/#it-should-look-like-below_2","title":"It should look like below:","text":"<pre><code># Create and configure route table\n\nrt_name = \"UnsecuredRT\"\nrt_response = ec2_client.create_route_table(\n    VpcId=vpc_id,\n    TagSpecifications=[\n        {\n            'ResourceType': 'route-table',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': rt_name\n                }\n            ]\n        }\n    ]\n)\nrt_id = rt_response['RouteTable']['RouteTableId']\n\n# Create route to Internet Gateway\nec2_client.create_route(RouteTableId=rt_id, DestinationCidrBlock='0.0.0.0/0', GatewayId=igw_id)\n\n# Associate route table with subnet\nec2_client.associate_route_table(RouteTableId=rt_id, SubnetId=subnet_id)\n\nprint(f\"Route table '{rt_name}' created and configured with ID: {rt_id}\")\n</code></pre>"},{"location":"lab1/zt-lab1/#access-the-vpc-service-route-tables-menu-in-aws-management-console","title":"Access the VPC Service Route Tables Menu in AWS Management Console.","text":""},{"location":"lab1/zt-lab1/#it-should-look-like-below_3","title":"It should look like below:","text":""},{"location":"lab1/zt-lab1/#step-3-create-an-unsecured-security-group","title":"Step 3: Create an Unsecured Security Group","text":"<p>Let's create a security group that allows all inbound traffic.</p> <pre><code># Create Security Group allowing all traffic in and out\n\nsg_name = \"UnsecuredSG\"\nsg_response = ec2_client.create_security_group(\n    GroupName=sg_name,\n    Description='Allow all inbound traffic',\n    VpcId=vpc_id,\n    TagSpecifications=[\n        {\n            'ResourceType': 'security-group',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': sg_name\n                }\n            ]\n        }\n    ]\n)\nsg_id = sg_response['GroupId']\n\n# Configure security group rules\nec2_client.authorize_security_group_ingress(\n    GroupId=sg_id,\n    IpPermissions=[\n        {'IpProtocol': '-1', 'FromPort': -1, 'ToPort': -1, 'IpRanges': [{'CidrIp': '0.0.0.0/0'}]}\n    ]\n)\n\nprint(f\"Unsecured security group '{sg_name}' created with ID: {sg_id}\")\n</code></pre>"},{"location":"lab1/zt-lab1/#access-the-vpc-security-groups-menu-in-aws-management-console","title":"Access the VPC Security Groups Menu in AWS Management Console.","text":""},{"location":"lab1/zt-lab1/#it-should-look-like-below_4","title":"It should look like below:","text":""},{"location":"lab1/zt-lab1/#step-4-deploy-backend-server","title":"Step 4: Deploy Backend Server","text":"<p>Now, let's deploy our backend server with a mock sensitive database.</p> <pre><code># Function to fetch the latest Amazon Linux 2 AMI ID with error handling and fallback\n\ndef get_latest_amazon_linux_2_ami():\n    try:\n        response = ec2_client.describe_images(\n            Owners=['amazon'],\n            Filters=[\n                {'Name': 'name', 'Values': ['amzn2-ami-hvm-*-x86_64-gp2']},\n                {'Name': 'state', 'Values': ['available']}\n            ]\n        )\n\n        if not response['Images']:\n            print(\"No Amazon Linux 2 AMIs found. Falling back to a default AMI ID.\")\n            return 'ami-0caa0a2e2a99b8b82'  # This is a fallback AMI ID, replace with a known good one for your region\n\n        # Sort the images by creation date\n        sorted_images = sorted(response['Images'], key=lambda x: x['CreationDate'], reverse=True)\n        latest_ami_id = sorted_images[0]['ImageId']\n        print(f\"Latest Amazon Linux 2 AMI ID: {latest_ami_id}\")\n        return latest_ami_id\n\n    except Exception as e:\n        print(f\"An error occurred while fetching the latest AMI: {str(e)}\")\n        print(\"Falling back to a default AMI ID.\")\n        return 'ami-0caa0a2e2a99b8b82'  # This is a fallback AMI ID, replace with a known good one for your region\n\n# Get the latest Amazon Linux 2 AMI ID\nami_id = get_latest_amazon_linux_2_ami()\nprint(f\"Using AMI ID: {ami_id}\")\n</code></pre> <pre><code># User data script for backend instance setup: installs and configures Apache with PHP\n\nbackend_user_data = '''#!/bin/bash\nyum update -y\nyum install -y httpd php\nsystemctl start httpd\nsystemctl enable httpd\ncat &lt;&lt;EOF &gt; /var/www/html/api.php\n&lt;?php\n\\$data = ['sensitive' =&gt; 'This is sensitive data from the backend'];\nheader('Content-Type: application/json');\necho json_encode(\\$data);\n?&gt;\nEOF\n'''\n</code></pre> <pre><code># Create and launch the backend EC2 instance with specified configuration\n\nbackend_instance = ec2_resource.create_instances(\n    ImageId=ami_id,  # Amazon Linux 2 AMI ID (replace with the latest)\n    InstanceType='t3.micro',\n    MaxCount=1,\n    MinCount=1,\n    NetworkInterfaces=[{\n        'SubnetId': subnet_id,\n        'DeviceIndex': 0,\n        'AssociatePublicIpAddress': True,\n        'Groups': [sg_id]\n    }],\n    UserData=backend_user_data,\n    TagSpecifications=[\n        {\n            'ResourceType': 'instance',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': 'BackendServer'\n                },\n            ]\n        },\n    ]\n)\nbackend_id = backend_instance[0].id\nprint(f\"Backend server deployed with ID: {backend_id}\")\n</code></pre> <pre><code># Wait for the instance to be running to get the IP addresses\nbackend_instance[0].wait_until_running()\nbackend_instance[0].reload()\n\n# Get private IP\nbackend_private_ip = backend_instance[0].private_ip_address\nprint(f\"Backend server private IP: {backend_private_ip}\")\n\n# Get public IP if it exists\nbackend_public_ip = backend_instance[0].public_ip_address\nif backend_public_ip:\n    print(f\"Backend server public IP: {backend_public_ip}\")\nelse:\n    print(\"Backend server does not have a public IP address.\")\n</code></pre>"},{"location":"lab1/zt-lab1/#access-the-ec2-security-groups-menu-in-aws-management-console","title":"Access the EC2 Security Groups Menu in AWS Management Console.","text":""},{"location":"lab1/zt-lab1/#it-should-look-like-below_5","title":"It should look like below:","text":""},{"location":"lab1/zt-lab1/#step-5-deploy-web-server","title":"Step 5: Deploy Web Server","text":"<p>Finally, let's deploy our public-facing web server.</p> <pre><code># User data script for frontend instance setup: installs and configures Apache with PHP\n\nweb_user_data = f'''#!/bin/bash\nyum update -y\nyum install -y httpd php\nsystemctl start httpd\nsystemctl enable httpd\necho \"&lt;?php\n\\\\$backend_ip = '{backend_private_ip}';\n\\\\$data = file_get_contents('http://' . \\\\$backend_ip . '/api.php');\necho '&lt;h1&gt;Welcome to our Unsecured Web Server!&lt;/h1&gt;';\necho '&lt;h2&gt;Data from backend:&lt;/h2&gt;';\necho \\\\$data;\n?&gt;\" &gt; /var/www/html/index.php\nsystemctl restart httpd\n'''\n</code></pre> <pre><code># Create and launch the frontend EC2 instance with specified configuration\n\nweb_instance = ec2_resource.create_instances(\n    ImageId=ami_id,  # Amazon Linux 2 AMI ID (replace with the latest)\n    InstanceType='t3.micro',\n    MaxCount=1,\n    MinCount=1,\n    NetworkInterfaces=[{\n        'SubnetId': subnet_id,\n        'DeviceIndex': 0,\n        'AssociatePublicIpAddress': True,\n        'Groups': [sg_id]\n    }],\n    UserData=web_user_data,\n    TagSpecifications=[\n        {\n            'ResourceType': 'instance',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': 'FrontendServer'\n                },\n            ]\n        },\n    ]\n)\nweb_id = web_instance[0].id\nprint(f\"Web server deployed with ID: {web_id}\")\n</code></pre> <pre><code># Wait for the instance to be running to get the IP addresses\nweb_instance[0].wait_until_running()\nweb_instance[0].reload()\n\n# Get private IP\nweb_private_ip = web_instance[0].private_ip_address\nprint(f\"Web server private IP: {web_private_ip}\")\n\n# Get public IP\nweb_public_ip = web_instance[0].public_ip_address\nif web_public_ip:\n    print(f\"Web server public IP: {web_public_ip}\")\nelse:\n    print(\"Web server does not have a public IP address.\")\n</code></pre>"},{"location":"lab1/zt-lab1/#access-the-ec2-instances-menu-in-aws-management-console","title":"Access the EC2 Instances Menu in AWS Management Console.","text":""},{"location":"lab1/zt-lab1/#it-should-look-like-below_6","title":"It should look like below:","text":""},{"location":"lab1/zt-lab1/#testing-the-unsecured-system","title":"Testing the Unsecured System","text":"<p>Now that our system is set up, let's test it by accessing the web server.</p> <pre><code># Wait for a bit to ensure the servers are fully initialized\n\nimport time\nimport boto3\n\ndef wait_for_ec2_instances(instance_ids, region_name, timeout=300, interval=10):\n    \"\"\"\n    Waits for the given EC2 instances to pass system and instance status checks within a timeout period.\n\n    Args:\n        instance_ids (list): A list of EC2 instance IDs to check.\n        region_name (str): The AWS region where the instances are located.\n        timeout (int): The maximum time to wait (in seconds) before giving up.\n        interval (int): The time interval (in seconds) between status checks.\n\n    Returns:\n        bool: True if all instances pass system and instance checks within the timeout, False otherwise.\n    \"\"\"\n    ec2 = boto3.client('ec2', region_name=region_name)\n    start_time = time.time()\n\n    while time.time() - start_time &lt; timeout:\n        # Check the status of the EC2 instances\n        response = ec2.describe_instance_status(InstanceIds=instance_ids)\n\n        # Get the instance statuses\n        statuses = {instance['InstanceId']: {\n                        'instance_state': instance['InstanceState']['Name'],\n                        'system_status': instance['SystemStatus']['Status'],\n                        'instance_status': instance['InstanceStatus']['Status']\n                    }\n                    for instance in response['InstanceStatuses']}\n\n        # Check if all instances are 'running' and both system and instance checks are 'ok'\n        all_ready = all(\n            status['instance_state'] == 'running' and \n            status['system_status'] == 'ok' and \n            status['instance_status'] == 'ok'\n            for status in statuses.values()\n        )\n\n        if all_ready:\n            print(f\"All instances {instance_ids} are fully initialized and passed all checks.\")\n            return True\n\n        print(f\"Current statuses: {statuses}\")\n        print(f\"Waiting for EC2 instances {instance_ids} to pass system and instance checks...\")\n        time.sleep(interval)\n\n    print(f\"Timeout: EC2 instances {instance_ids} did not fully initialize within {timeout} seconds.\")\n    return False\n\n# IDs of front-end and back-end EC2 instances\nfrontend_instance_id = web_id  # Replace with your front-end instance ID\nbackend_instance_id = backend_id   # Replace with your back-end instance ID\nregion = 'us-west-2'  # Replace with your region\n\n# Wait for both front-end and back-end instances to be fully initialized\nif wait_for_ec2_instances([frontend_instance_id, backend_instance_id], region_name=region):\n    print(\"Both EC2 instances are fully initialized!\")\nelse:\n    print(\"One or both EC2 instances failed to fully initialize within the timeout.\")\n\n</code></pre> <pre><code># Access the web server\n\n# Get public IP\nweb_public_ip = web_instance[0].public_ip_address\nif web_public_ip:\n    print(f\"Web server public IP: {web_public_ip}\")\nelse:\n    print(\"Web server does not have a public IP address.\")\n\nimport requests\nprint(\"Accessing the web server:\")\nresponse = requests.get(f\"http://{web_public_ip}\")\nprint(response.text)\n</code></pre>"},{"location":"lab1/zt-lab1/#access-the-frontend-web-server-by-entering-the-public-ip-in-a-browser-tab","title":"Access the frontend web server by entering the Public IP in a browser tab.","text":""},{"location":"lab1/zt-lab1/#it-should-look-like-below_7","title":"It should look like below:","text":"<pre><code># Access the backend server\n\n# Get public IP if it exists\nbackend_public_ip = backend_instance[0].public_ip_address\nif backend_public_ip:\n    print(f\"Backend server public IP: {backend_public_ip}\")\nelse:\n    print(\"Backend server does not have a public IP address.\")\n\nimport requests\nprint(\"Accessing the web server:\")\nresponse = requests.get(f\"http://{web_public_ip}\")\nprint(response.text)\n</code></pre>"},{"location":"lab1/zt-lab1/#access-the-backend-web-server-by-entering-the-public-ip-in-a-browser-tab-with-apiphp","title":"Access the backend web server by entering the Public IP in a browser tab with /api.php","text":""},{"location":"lab1/zt-lab1/#it-should-look-like-below_8","title":"It should look like below:","text":""},{"location":"lab1/zt-lab1/#conclusion","title":"Conclusion","text":"<p>In this lab, we've set up an unsecured system in AWS and explored its components. We've seen how easy it is to access sensitive information due to the lack of proper security measures. In the upcoming labs, we'll start implementing Zero Trust principles to secure this system.</p>"},{"location":"lab1/zt-lab1/#cleanup","title":"Cleanup","text":"<p>To avoid unnecessary charges, let's clean up our resources:</p> <pre><code>import boto3\nimport time\nimport botocore\n\n# Initialize AWS clients\nec2 = boto3.client('ec2')\nlambda_client = boto3.client('lambda')\napigateway = boto3.client('apigateway')\niam = boto3.client('iam')\n\ndef wait_for_deletion(resource_type, resource_id, check_function):\n    print(f\"Confirming deletion of {resource_type} {resource_id}...\")\n    max_attempts = 30\n    for _ in range(max_attempts):\n        try:\n            if not check_function(resource_id):\n                print(f\"{resource_type} {resource_id} has been deleted.\")\n                return True\n        except botocore.exceptions.ClientError as e:\n            if e.response['Error']['Code'] == 'InvalidVpcID.NotFound':\n                print(f\"{resource_type} {resource_id} has been deleted.\")\n                return True\n        print(f\"{resource_type} {resource_id} is still being deleted. Waiting...\")\n        time.sleep(10)\n    print(f\"Timeout waiting for {resource_type} {resource_id} to be deleted.\")\n    return False\n\n\ndef delete_ec2_instances():\n    print(\"Deleting EC2 instances...\")\n    response = ec2.describe_instances(\n        Filters=[{'Name': 'instance-state-name', 'Values': ['pending', 'running', 'stopping', 'stopped']}]\n    )\n    instance_ids = [instance['InstanceId'] for reservation in response['Reservations'] for instance in reservation['Instances']]\n    if instance_ids:\n        ec2.terminate_instances(InstanceIds=instance_ids)\n        waiter = ec2.get_waiter('instance_terminated')\n        waiter.wait(InstanceIds=instance_ids)\n    print(\"EC2 instances deleted.\")\n\ndef delete_security_groups():\n    print(\"Deleting security groups...\")\n    response = ec2.describe_security_groups()\n    for sg in response['SecurityGroups']:\n        if sg['GroupName'] != 'default':\n            try:\n                ec2.delete_security_group(GroupId=sg['GroupId'])\n                print(f\"Security group {sg['GroupId']} deleted.\")\n            except botocore.exceptions.ClientError as e:\n                print(f\"Error deleting security group {sg['GroupId']}: {e}\")\n    print(\"Security group deletion attempted.\")\n\ndef delete_nat_gateway():\n    print(\"Deleting NAT Gateways...\")\n    response = ec2.describe_nat_gateways()\n    for nat_gateway in response['NatGateways']:\n        ec2.delete_nat_gateway(NatGatewayId=nat_gateway['NatGatewayId'])\n        wait_for_deletion('NAT Gateway', nat_gateway['NatGatewayId'], \n                          lambda id: ec2.describe_nat_gateways(NatGatewayIds=[id])['NatGateways'][0]['State'] != 'deleted')\n\n    # Release Elastic IPs\n    response = ec2.describe_addresses()\n    for eip in response['Addresses']:\n        if 'AssociationId' not in eip:\n            ec2.release_address(AllocationId=eip['AllocationId'])\n    print(\"NAT Gateways deleted and Elastic IPs released.\")\n\ndef delete_internet_gateway():\n    print(\"Deleting Internet Gateways...\")\n    response = ec2.describe_internet_gateways()\n    for igw in response['InternetGateways']:\n        if igw['Attachments']:\n            ec2.detach_internet_gateway(InternetGatewayId=igw['InternetGatewayId'], VpcId=igw['Attachments'][0]['VpcId'])\n        ec2.delete_internet_gateway(InternetGatewayId=igw['InternetGatewayId'])\n    print(\"Internet Gateways deleted.\")\n\ndef delete_subnets():\n    print(\"Deleting subnets...\")\n    response = ec2.describe_subnets()\n    for subnet in response['Subnets']:\n        if not subnet['DefaultForAz']:\n            ec2.delete_subnet(SubnetId=subnet['SubnetId'])\n    print(\"Subnets deleted.\")\n\ndef delete_route_tables():\n    print(\"Deleting route tables...\")\n    response = ec2.describe_route_tables()\n    for rt in response['RouteTables']:\n        if not rt.get('Associations') or not any(assoc.get('Main') for assoc in rt.get('Associations')):\n            ec2.delete_route_table(RouteTableId=rt['RouteTableId'])\n    print(\"Route tables deleted.\")\n\ndef delete_vpc():\n    print(\"Deleting VPCs...\")\n    response = ec2.describe_vpcs()\n    for vpc in response['Vpcs']:\n        if not vpc['IsDefault']:\n            try:\n                print(f\"Attempting to delete VPC {vpc['VpcId']}...\")\n                ec2.delete_vpc(VpcId=vpc['VpcId'])\n                wait_for_deletion('VPC', vpc['VpcId'], \n                                  lambda id: bool(ec2.describe_vpcs(VpcIds=[id])['Vpcs']))\n            except botocore.exceptions.ClientError as e:\n                if e.response['Error']['Code'] == 'InvalidVpcID.NotFound':\n                    print(f\"VPC {vpc['VpcId']} has already been deleted.\")\n                else:\n                    print(f\"Error deleting VPC {vpc['VpcId']}: {e}\")\n                    print(\"Please check and manually delete any remaining resources in this VPC.\")\n    print(\"VPC deletion completed.\")\n\n\ndef delete_lambda_function():\n    print(\"Deleting Lambda functions...\")\n    lambda_functions = lambda_client.list_functions()\n    for function in lambda_functions['Functions']:\n        if function['FunctionName'].startswith('IdentityProviderFunction-'):\n            lambda_client.delete_function(FunctionName=function['FunctionName'])\n    print(\"Lambda functions deleted.\")\n\ndef delete_api_gateway():\n    print(\"Deleting API Gateway...\")\n    apis = apigateway.get_rest_apis()\n    for api in apis['items']:\n        if api['name'] == 'IdentityProviderApi':\n            apigateway.delete_rest_api(restApiId=api['id'])\n    print(\"API Gateway deleted.\")\n\ndef delete_iam_role():\n    print(\"Deleting IAM roles...\")\n    roles = iam.list_roles()\n    for role in roles['Roles']:\n        if role['RoleName'].startswith('LabLambdaExecutionRole-'):\n            attached_policies = iam.list_attached_role_policies(RoleName=role['RoleName'])\n            for policy in attached_policies['AttachedPolicies']:\n                iam.detach_role_policy(RoleName=role['RoleName'], PolicyArn=policy['PolicyArn'])\n            iam.delete_role(RoleName=role['RoleName'])\n    print(\"IAM roles deleted.\")\n\ndef cleanup():\n    delete_ec2_instances()\n    delete_nat_gateway()\n    delete_internet_gateway()\n    delete_subnets()\n    delete_route_tables()\n    delete_security_groups()\n    delete_vpc()\n    delete_lambda_function()\n    delete_api_gateway()\n    delete_iam_role()\n    print(\"Cleanup completed.\")\n\n# Run the cleanup\ncleanup()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"lab3/zt-lab3/","title":"Traditional Perimeter-Based Security","text":""},{"location":"lab3/zt-lab3/#lab-3-creating-a-traditionally-secured-system","title":"Lab 3: Creating a Traditionally-Secured System","text":""},{"location":"lab3/zt-lab3/#introduction","title":"Introduction","text":"<p>Welcome to the lab of our Zero Trust course! In this lab, we'll set up a basic, traditionally-secured system in AWS using AWS CLI commands and Python (boto3). This hands-on approach will help you understand each component of the system and why better security practices are necessary.</p> <p> Try the simulation here NetworkSecurityDemo ID: admin, PW: password123</p>"},{"location":"lab3/zt-lab3/#objectives","title":"Objectives","text":"<p>By the end of this lab, you will: 1. Create a Virtual Private Cloud (VPC) with a public and private subnets 2. Set up an Internet Gateway and configure routing 3. Setup a NAT Gateway 3. Create a security group with restricted access 4. Setup Secrets Manager 5. Deploy a \"sensitive\" backend server 6. Launch a public-facing web server 7. (not implemented) CloudTrail (API log) and CloudWatch (Metric and Event Monitoring) for ovservability</p> <p></p>"},{"location":"lab3/zt-lab3/#setup","title":"Setup","text":"<p>First, let's set up our AWS environment. Make sure you have configured your AWS CLI with the appropriate credentials.</p> <pre><code># Import necessary AWS SDK and utility modules\n\nimport boto3\nimport json\nimport time\n</code></pre>"},{"location":"lab3/zt-lab3/#set-the-aws-region","title":"Set the AWS region","text":"<p>Configure the AWS region to create the network and servers</p> <pre><code># Set the AWS region for resource creation (change as needed)\n\nregion = 'us-west-2'\n</code></pre>"},{"location":"lab3/zt-lab3/#initialize-aws-clients","title":"Initialize AWS clients","text":"<p>Setup the necessary environment variables</p> <pre><code># Initialize EC2 client and resource objects for interacting with AWS\n\nec2_client = boto3.client('ec2', region_name=region)\nec2_resource = boto3.resource('ec2', region_name=region)\nsecretsmanager = boto3.client('secretsmanager', region_name=region)\niam = boto3.client('iam', region_name=region)\n\nprint(f\"AWS environment initialized in region: {region}\")\n</code></pre>"},{"location":"lab3/zt-lab3/#initialize-value-store","title":"Initialize Value Store","text":"<p>Initialize long-term storage</p> <pre><code>class ValueStore:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super(ValueStore, cls).__new__(cls)\n            cls._instance.store = {}\n        return cls._instance\n\n    def set(self, key, value):\n        self.store[key] = value\n\n    def get(self, key, default=None):\n        return self.store.get(key, default)\n\n    def print_all(self):\n        for key, value in self.store.items():\n            print(f\"{key}: {value}\")\n\n# Create a global instance\nvalue_store = ValueStore()\n\n# Test the ValueStore\nvalue_store.set('test_key', 'test_value')\nprint(value_store.get('test_key'))  # Should print: test_value\n</code></pre>"},{"location":"lab3/zt-lab3/#step-1-create-a-vpc-and-subnet","title":"Step 1: Create a VPC and Subnet","text":"<p>Let's start by creating our Virtual Private Cloud (VPC) and a public subnet.</p> <pre><code># Create VPC\n\nvpc_response = ec2_client.create_vpc(CidrBlock='10.0.0.0/16')\nvpc_id = vpc_response['Vpc']['VpcId']\nec2_client.create_tags(Resources=[vpc_id], Tags=[{'Key': 'Name', 'Value': 'TraditionalSecuredVPC'}])\n\nvalue_store.set('vpc_id', vpc_id)\n\nprint(f\"VPC created with ID: {vpc_id}\")\n</code></pre>"},{"location":"lab3/zt-lab3/#access-the-vpc-vpc-menu-in-aws-management-console","title":"Access the VPC - VPC Menu in AWS Management Console.","text":""},{"location":"lab3/zt-lab3/#it-should-look-like-below","title":"It should look like below:","text":"<pre><code># Get available Availability Zones\n\navailable_azs = ec2_client.describe_availability_zones()['AvailabilityZones']\naz = available_azs[0]['ZoneName']  # Choose the first available AZ\n\n# Create Public subnet\npublic_subnet_response = ec2_client.create_subnet(\n    VpcId=value_store.get('vpc_id'),\n    CidrBlock='10.0.1.0/24',\n    AvailabilityZone=az,\n    TagSpecifications=[\n        {\n            'ResourceType': 'subnet',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': 'PublicSubnet'\n                }\n            ]\n        }\n    ]\n)\npublic_subnet_id = public_subnet_response['Subnet']['SubnetId']\nprint(f\"Public subnet created with ID: {public_subnet_id} in Availability Zone: {az}\")\n\n# Enable auto-assign public IP for the public subnet\nec2_client.modify_subnet_attribute(\n    SubnetId=public_subnet_id,\n    MapPublicIpOnLaunch={'Value': True}\n)\nprint(\"Auto-assign public IP enabled for the public subnet\")\n</code></pre> <pre><code># First, let's find the public subnet ID\npublic_subnets = ec2_client.describe_subnets(\n    Filters=[\n        {'Name': 'vpc-id', 'Values': [vpc_id]},\n        {'Name': 'tag:Name', 'Values': ['PublicSubnet']}\n    ]\n)['Subnets']\n\nif not public_subnets:\n    raise ValueError(\"No public subnet found. Please ensure you've created a public subnet with the tag 'Name: PublicSubnet'\")\n\npublic_subnet_id = public_subnets[0]['SubnetId']\npublic_subnet_az = public_subnets[0]['AvailabilityZone']\n\nprint(f\"Found public subnet with ID: {public_subnet_id} in Availability Zone: {public_subnet_az}\")\n\n# Now create the Private subnet in the same Availability Zone\nprivate_subnet_response = ec2_client.create_subnet(\n    VpcId=value_store.get('vpc_id'), \n    CidrBlock='10.0.2.0/24',  # Different CIDR block for the private subnet\n    AvailabilityZone=public_subnet_az,\n    TagSpecifications=[\n        {\n            'ResourceType': 'subnet',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': 'PrivateSubnet'\n                }\n            ]\n        }\n    ]\n)\nprivate_subnet_id = private_subnet_response['Subnet']['SubnetId']\nprint(f\"Private subnet created with ID: {private_subnet_id} in the same AZ as the public subnet: {public_subnet_az}\")\n\n# Modify the private subnet to disable auto-assign public IP\nec2_client.modify_subnet_attribute(SubnetId=private_subnet_id, MapPublicIpOnLaunch={'Value': False})\nprint(\"Auto-assign public IP disabled for the private subnet\")\n</code></pre>"},{"location":"lab3/zt-lab3/#access-the-vpc-subnets-menu-in-aws-management-console","title":"Access the VPC - Subnets Menu in AWS Management Console.","text":""},{"location":"lab3/zt-lab3/#it-should-look-like-below_1","title":"It should look like below:","text":""},{"location":"lab3/zt-lab3/#public-subnet","title":"Public Subnet","text":""},{"location":"lab3/zt-lab3/#private-subnet","title":"Private Subnet","text":""},{"location":"lab3/zt-lab3/#step-2-set-up-internet-gateway","title":"Step 2: Set up Internet Gateway","text":"<p>Now, let's create an Internet Gateway.</p> <pre><code># Create Internet Gateway\nigw_name = \"TraditionalSecuredIGW\"\nigw_response = ec2_client.create_internet_gateway(\n    TagSpecifications=[\n        {\n            'ResourceType': 'internet-gateway',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': igw_name\n                }\n            ]\n        }\n    ]\n)\nigw_id = igw_response['InternetGateway']['InternetGatewayId']\nec2_client.attach_internet_gateway(InternetGatewayId=igw_id, VpcId=value_store.get('vpc_id'))\nprint(f\"Internet Gateway '{igw_name}' created and attached with ID: {igw_id}\")\n</code></pre>"},{"location":"lab3/zt-lab3/#access-the-vpc-internet-gateways-menu-in-aws-management-console","title":"Access the VPC - Internet Gateways Menu in AWS Management Console.","text":""},{"location":"lab3/zt-lab3/#it-should-look-like-below_2","title":"It should look like below:","text":""},{"location":"lab3/zt-lab3/#step-3-set-up-nat-gateway","title":"Step 3: Set up NAT Gateway","text":"<p>Next, let's create a NAT Gateway (Network Address Translation) to give instances in private subnet access to the Internet.</p> <pre><code># Setup NAT Gateway\n# Note: This will take a few minutes\n\ndef setup_nat_gateway(vpc_id, public_subnet_id, nat_gateway_name=\"TraditionalSecuredNATGW\"):\n    # Create Elastic IP\n    eip = ec2_client.allocate_address(Domain='vpc')\n\n    # Create NAT Gateway with a name tag\n    nat_gateway = ec2_client.create_nat_gateway(\n        SubnetId=public_subnet_id,\n        AllocationId=eip['AllocationId'],\n        TagSpecifications=[\n            {\n                'ResourceType': 'natgateway',\n                'Tags': [\n                    {\n                        'Key': 'Name',\n                        'Value': nat_gateway_name\n                    }\n                ]\n            }\n        ]\n    )\n\n    # Wait for the NAT Gateway to be available\n    waiter = ec2_client.get_waiter('nat_gateway_available')\n    waiter.wait(\n        NatGatewayIds=[nat_gateway['NatGateway']['NatGatewayId']],\n        WaiterConfig={'Delay': 30, 'MaxAttempts': 10}\n    )\n\n    print(f\"NAT Gateway '{nat_gateway_name}' created with ID: {nat_gateway['NatGateway']['NatGatewayId']}\")\n    return nat_gateway['NatGateway']['NatGatewayId']\n\n# Create the NAT Gateway\nnat_gateway_id = setup_nat_gateway(value_store.get('vpc_id'), public_subnet_id)\nprint(f\"NAT Gateway setup complete with ID: {nat_gateway_id}\")\n</code></pre>"},{"location":"lab3/zt-lab3/#access-the-vpc-nat-gateways-menu-in-aws-management-console","title":"Access the VPC - NAT Gateways Menu in AWS Management Console.","text":""},{"location":"lab3/zt-lab3/#it-should-look-like-below_3","title":"It should look like below:","text":"<pre><code># Create and configure Public route table\n\nrt_name = \"TraditionalSecuredPublicRT\"\nrt_response = ec2_client.create_route_table(\n    VpcId=value_store.get('vpc_id'),\n    TagSpecifications=[\n        {\n            'ResourceType': 'route-table',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': rt_name\n                }\n            ]\n        }\n    ]\n)\nrt_id = rt_response['RouteTable']['RouteTableId']\n\n# Create route to Internet Gateway\nec2_client.create_route(RouteTableId=rt_id, DestinationCidrBlock='0.0.0.0/0', GatewayId=igw_id)\n\n# Associate route table with subnet\nec2_client.associate_route_table(RouteTableId=rt_id, SubnetId=public_subnet_id)\n\nprint(f\"Route table '{rt_name}' created and configured with ID: {rt_id}\")\n</code></pre>"},{"location":"lab3/zt-lab3/#access-the-vpc-public-route-tables-menu-in-aws-management-console","title":"Access the VPC - Public Route Tables Menu in AWS Management Console.","text":""},{"location":"lab3/zt-lab3/#it-should-look-like-below_4","title":"It should look like below:","text":"<pre><code># Create and configure Private route table\n\nprivate_rt_name = \"TraditionalSecuredPrivateRT\"\nprivate_rt_response = ec2_client.create_route_table(\n    VpcId=value_store.get('vpc_id'),\n    TagSpecifications=[\n        {\n            'ResourceType': 'route-table',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': private_rt_name\n                }\n            ]\n        }\n    ]\n)\nprivate_rt_id = private_rt_response['RouteTable']['RouteTableId']\n\n# Create route to NAT Gateway\nec2_client.create_route(\n    RouteTableId=private_rt_id, \n    DestinationCidrBlock='0.0.0.0/0', \n    NatGatewayId=nat_gateway_id\n)\n\n# Associate route table with private subnet\nec2_client.associate_route_table(RouteTableId=private_rt_id, SubnetId=private_subnet_id)\n\nprint(f\"Private route table '{private_rt_name}' created and configured with ID: {private_rt_id}\")\n\n# Optionally, you can describe the route table to verify its configuration\nroutes = ec2_client.describe_route_tables(RouteTableIds=[private_rt_id])\nprint(f\"Routes in the private route table: {routes['RouteTables'][0]['Routes']}\")\n</code></pre>"},{"location":"lab3/zt-lab3/#access-the-vpc-private-route-tables-menu-in-aws-management-console","title":"Access the VPC - Private Route Tables Menu in AWS Management Console.","text":""},{"location":"lab3/zt-lab3/#it-should-look-like-below_5","title":"It should look like below:","text":""},{"location":"lab3/zt-lab3/#step-4-create-an-traditional-secured-security-groups","title":"Step 4: Create an Traditional Secured Security Groups","text":"<p>Let's create a security group that allows for following: 1. FrontendSG: Allow traffic to port 80 from all locations 2. BackendSG: Allow traffic to pourt 80 from instance that is assigned FrontendSG</p> <pre><code>import boto3\nec2_client = boto3.client('ec2')\n\ndef create_security_groups(vpc_id):\n    # FRONTEND SECURITY GROUP\n    # Create Web Server Security Group\n    frontend_sg = ec2_client.create_security_group(\n        GroupName='FrontendSG',\n        Description='Allow HTTP access to web server',\n        VpcId=vpc_id\n    )\n    frontend_sg_id = frontend_sg['GroupId']\n\n    # Add Name tag to Frontend Security Group\n    ec2_client.create_tags(\n        Resources=[frontend_sg_id],\n        Tags=[{'Key': 'Name', 'Value': 'FrontendSG'}]\n    )\n\n    # Add inbound rule to allow HTTP traffic from anywhere\n    ec2_client.authorize_security_group_ingress(\n        GroupId=frontend_sg_id,\n        IpPermissions=[\n            {'IpProtocol': 'tcp', 'FromPort': 80, 'ToPort': 80, 'IpRanges': [{'CidrIp': '0.0.0.0/0'}]}\n        ]\n    )\n\n    # BACKEND SECURITY GROUP\n    # Create Backend Server Security Group\n    backend_sg = ec2_client.create_security_group(\n        GroupName='BackendSG',\n        Description='Allow access from web server to backend server',\n        VpcId=vpc_id\n    )\n    backend_sg_id = backend_sg['GroupId']\n\n    # Add Name tag to Backend Security Group\n    ec2_client.create_tags(\n        Resources=[backend_sg_id],\n        Tags=[{'Key': 'Name', 'Value': 'BackendSG'}]\n    )\n\n    # Add inbound rule to allow all TCP traffic from the frontend security group\n    ec2_client.authorize_security_group_ingress(\n        GroupId=backend_sg_id,\n        IpPermissions=[\n            {'IpProtocol': 'tcp', 'FromPort': 0, 'ToPort': 65535, 'UserIdGroupPairs': [{'GroupId': frontend_sg_id}]}\n        ]\n    )\n    value_store.set('frontend_sg_id', frontend_sg_id)\n    value_store.set('backend_sg_id', backend_sg_id)\n\n    print(f\"Frontend Server Security Group ID: {frontend_sg_id}\")\n    print(f\"Backend Server Security Group ID: {backend_sg_id}\")\n    return frontend_sg_id, backend_sg_id\n\n# Usage example\nweb_sg_id, backend_sg_id = create_security_groups(value_store.get('vpc_id'))\n</code></pre>"},{"location":"lab3/zt-lab3/#access-the-vpc-security-groups-menu-in-aws-management-console","title":"Access the VPC - Security Groups Menu in AWS Management Console.","text":""},{"location":"lab3/zt-lab3/#it-should-look-like-below_6","title":"It should look like below:","text":""},{"location":"lab3/zt-lab3/#frontend-sg","title":"Frontend SG","text":""},{"location":"lab3/zt-lab3/#backend-sg","title":"Backend SG","text":""},{"location":"lab3/zt-lab3/#step-5-setup-aws-secrets-manager","title":"Step 5: Setup AWS Secrets Manager","text":"<p>Let's create a secret in AWS Secrets Manager to store our web server credentials.</p> <ul> <li>Username: admin</li> <li>Password: password123</li> </ul> <pre><code># Setup the username and password for accessing the sensitive data\n\nimport random\nimport string\n\ndef generate_unique_name(base_name, length=8):\n    random_suffix = ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))\n    return f\"{base_name}-{random_suffix}\"\n\ndef setup_secrets_manager():\n    secret_name = generate_unique_name('WebServerCredentials')\n    secret_value = json.dumps({\n        'username': 'admin',\n        'password': 'password123'  # In a real scenario, use a strong, randomly generated password\n    })\n\n    secret = secretsmanager.create_secret(\n        Name=secret_name,\n        Description='Credentials for Web Server authentication',\n        SecretString=secret_value\n    )\n\n    print(f\"Secret created with ARN: {secret['ARN']}\")\n    print(f\"Secret Name: {secret_name}\")\n    return secret['ARN'], secret_name\n\nsecret_arn, secret_name = setup_secrets_manager()\n</code></pre>"},{"location":"lab3/zt-lab3/#access-the-secrets-manager-sectets-menu-in-aws-management-console","title":"Access the Secrets Manager - Sectets Menu in AWS Management Console.","text":""},{"location":"lab3/zt-lab3/#it-should-look-like-below_7","title":"It should look like below:","text":""},{"location":"lab3/zt-lab3/#step-6-create-iam-role-for-web-server","title":"Step 6: Create IAM Role for Web Server","text":"<p>Now, let's create an IAM role that allows the web server to access the secret we just created.</p> <pre><code>def create_iam_role(secret_arn):\n    import random\n    import string\n    def generate_unique_name(base_name, length=8):\n        random_suffix = ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))\n        return f\"{base_name}-{random_suffix}\"\n\n    role_name = generate_unique_name('WebServerRole')\n    policy_name = generate_unique_name('WebServerSecretAccess')\n    instance_profile_name = generate_unique_name('WebServerInstanceProfile')\n\n    assume_role_policy = json.dumps({\n        \"Version\": \"2012-10-17\",\n        \"Statement\": [\n            {\n                \"Effect\": \"Allow\",\n                \"Principal\": {\"Service\": \"ec2.amazonaws.com\"},\n                \"Action\": \"sts:AssumeRole\"\n            }\n        ]\n    })\n\n    role = iam.create_role(\n        RoleName=role_name,\n        AssumeRolePolicyDocument=assume_role_policy\n    )\n\n    policy = iam.create_policy(\n        PolicyName=policy_name,\n        PolicyDocument=json.dumps({\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n                {\n                    \"Effect\": \"Allow\",\n                    \"Action\": \"secretsmanager:GetSecretValue\",\n                    \"Resource\": secret_arn\n                }\n            ]\n        })\n    )\n\n    iam.attach_role_policy(\n        RoleName=role_name,\n        PolicyArn=policy['Policy']['Arn']\n    )\n\n    # Create an instance profile and add the role to it\n    instance_profile = iam.create_instance_profile(InstanceProfileName=instance_profile_name)\n    iam.add_role_to_instance_profile(InstanceProfileName=instance_profile_name, RoleName=role_name)\n\n    print(f\"IAM Role created: {role['Role']['Arn']}\")\n    print(f\"Role Name: {role_name}\")\n    print(f\"Policy Name: {policy_name}\")\n    print(f\"Instance Profile Name: {instance_profile_name}\")\n    print(f\"Instance Profile ARN: {instance_profile['InstanceProfile']['Arn']}\")\n\n    return role['Role']['Arn'], role_name, policy_name, instance_profile['InstanceProfile']['Arn']\n\nrole_arn, role_name, policy_name, instance_profile_arn = create_iam_role(secret_arn)\n</code></pre>"},{"location":"lab3/zt-lab3/#access-the-iam-role-menu-in-aws-management-console","title":"Access the IAM - Role Menu in AWS Management Console.","text":""},{"location":"lab3/zt-lab3/#it-should-look-like-below_8","title":"It should look like below:","text":""},{"location":"lab3/zt-lab3/#step-7-deploy-backend-server","title":"Step 7: Deploy Backend Server","text":"<p>Now, let's deploy our backend server with a mock sensitive database.</p> <pre><code># Function to fetch the latest Amazon Linux 2 AMI ID with error handling and fallback\n\ndef get_latest_amazon_linux_2_ami():\n    try:\n        response = ec2_client.describe_images(\n            Owners=['amazon'],\n            Filters=[\n                {'Name': 'name', 'Values': ['amzn2-ami-hvm-*-x86_64-gp2']},\n                {'Name': 'state', 'Values': ['available']}\n            ]\n        )\n\n        if not response['Images']:\n            print(\"No Amazon Linux 2 AMIs found. Falling back to a default AMI ID.\")\n            return 'ami-0caa0a2e2a99b8b82'  # This is a fallback AMI ID, replace with a known good one for your region\n\n        # Sort the images by creation date\n        sorted_images = sorted(response['Images'], key=lambda x: x['CreationDate'], reverse=True)\n        latest_ami_id = sorted_images[0]['ImageId']\n        print(f\"Latest Amazon Linux 2 AMI ID: {latest_ami_id}\")\n        return latest_ami_id\n\n    except Exception as e:\n        print(f\"An error occurred while fetching the latest AMI: {str(e)}\")\n        print(\"Falling back to a default AMI ID.\")\n        return 'ami-0caa0a2e2a99b8b82'  # This is a fallback AMI ID, replace with a known good one for your region\n\n# Get the latest Amazon Linux 2 AMI ID\nami_id = get_latest_amazon_linux_2_ami()\nprint(f\"Using AMI ID: {ami_id}\")\n</code></pre> <pre><code># User data script for backend instance setup: installs and configures Apache with PHP\n\nbackend_user_data = '''#!/bin/bash\nyum update -y\nyum install -y httpd php\nsystemctl start httpd\nsystemctl enable httpd\ncat &lt;&lt;EOF &gt; /var/www/html/api.php\n&lt;?php\n\\$data = ['sensitive' =&gt; 'This is sensitive data from the backend'];\nheader('Content-Type: application/json');\necho json_encode(\\$data);\n?&gt;\nEOF\n'''\n</code></pre> <pre><code># Create and launch the backend EC2 instance with specified configuration\n# Only assign Private IP\n\nbackend_instance = ec2_resource.create_instances(\n    ImageId=ami_id,  # Amazon Linux 2 AMI ID (replace with the latest)\n    InstanceType='t3.micro',\n    MaxCount=1,\n    MinCount=1,\n    NetworkInterfaces=[{\n        'SubnetId': private_subnet_id,\n        'DeviceIndex': 0,\n        'AssociatePublicIpAddress': False,\n        'Groups': [value_store.get('backend_sg_id')]\n    }],\n    UserData=backend_user_data,\n    TagSpecifications=[\n        {\n            'ResourceType': 'instance',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': 'BackendServer'\n                },\n            ]\n        },\n    ]\n)\nbackend_id = backend_instance[0].id\nprint(f\"Backend server deployed with ID: {backend_id}\")\n</code></pre> <pre><code># Wait for the instance to be running to get the IP addresses\nbackend_instance[0].wait_until_running()\nbackend_instance[0].reload()\n\n# Get private IP\nbackend_private_ip = backend_instance[0].private_ip_address\nprint(f\"Backend server private IP: {backend_private_ip}\")\n\n# Get public IP if it exists\nbackend_public_ip = backend_instance[0].public_ip_address\nif backend_public_ip:\n    print(f\"Backend server public IP: {backend_public_ip}\")\nelse:\n    print(\"Backend server does not have a public IP address.\")\n</code></pre>"},{"location":"lab3/zt-lab3/#access-the-ec2-be-instances-menu-in-aws-management-console","title":"Access the EC2 - BE Instances Menu in AWS Management Console.","text":""},{"location":"lab3/zt-lab3/#it-should-look-like-below_9","title":"It should look like below:","text":""},{"location":"lab3/zt-lab3/#server-details-tab","title":"Server Details Tab","text":""},{"location":"lab3/zt-lab3/#server-security-tab","title":"Server Security Tab","text":""},{"location":"lab3/zt-lab3/#step-8-deploy-frontend-web-server","title":"Step 8: Deploy Frontend Web Server","text":"<p>Finally, let's deploy our public-facing web server.</p> <pre><code># User data script for frontend instance setup: installs and configures Apache with PHP\n# Create a simple login screen that will verify the credentials with Secrets Manager\n\nfrontend_user_data = f'''#!/bin/bash\nexec &gt; &gt;(tee /var/log/user-data.log|logger -t user-data -s 2&gt;/dev/console) 2&gt;&amp;1\necho \"Starting user data script execution\"\nyum update -y\nyum install -y httpd php aws-cli\nsystemctl start httpd\nsystemctl enable httpd\necho \"date.timezone = America/New_York\" &gt;&gt; /etc/php.ini\ncat &lt;&lt;'EOT' &gt; /var/www/html/index.php\n&lt;?php\nerror_reporting(E_ALL);\nini_set('display_errors', 1);\nsession_start();\n\nfunction getSecret() {{\n    $region = '{region}';\n    $output = shell_exec(\"aws secretsmanager get-secret-value --secret-id {secret_name} --query SecretString --output text --region $region\");\n    return json_decode($output, true);\n}}\n\n$secret = getSecret();\nif ($secret) {{\n    $USERNAME = $secret['username'];\n    $PASSWORD = $secret['password'];\n}} else {{\n    die(\"Error: Unable to fetch credentials\");\n}}\n\n$error_message = \"\";\n\nif ($_SERVER['REQUEST_METHOD'] === 'POST') {{\n    if (isset($_POST['logout'])) {{\n        session_destroy();\n        header(\"Location: \" . $_SERVER['PHP_SELF']);\n        exit();\n    }} elseif (isset($_POST['reset'])) {{\n        session_destroy();\n        header(\"Location: \" . $_SERVER['PHP_SELF']);\n        exit();\n    }} elseif (isset($_POST['username']) &amp;&amp; isset($_POST['password'])) {{\n        if ($_POST['username'] === $USERNAME &amp;&amp; $_POST['password'] === $PASSWORD) {{\n            $_SESSION['authenticated'] = true;\n        }} else {{\n            $error_message = \"Invalid username or password. Please try again.\";\n        }}\n    }}\n}}\n?&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Secure Web Server&lt;/title&gt;\n    &lt;style&gt;\n        body {{ font-family: Arial, sans-serif; margin: 0; padding: 20px; }}\n        .container {{ max-width: 600px; margin: 0 auto; }}\n        .error {{ color: red; }}\n        form {{ margin-top: 20px; }}\n        input {{ margin-bottom: 10px; }}\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;?php\n        if (isset($_SESSION['authenticated']) &amp;&amp; $_SESSION['authenticated'] === true) {{\n            $backend_ip = \"{backend_private_ip}\";\n            $data = @file_get_contents(\"http://$backend_ip/api.php\");\n            if ($data === false) {{\n                echo \"&lt;h1&gt;Error connecting to backend server&lt;/h1&gt;\";\n                echo \"&lt;p&gt;Please check the backend server configuration.&lt;/p&gt;\";\n            }} else {{\n                echo \"&lt;h1&gt;Welcome to our Secure Web Server!&lt;/h1&gt;\";\n                echo \"&lt;h2&gt;Data from backend:&lt;/h2&gt;\";\n                echo $data;\n            }}\n            echo \"&lt;form method='post'&gt;\";\n            echo \"&lt;input type='submit' name='logout' value='Logout'&gt;\";\n            echo \"&lt;input type='submit' name='reset' value='Reset'&gt;\";\n            echo \"&lt;/form&gt;\";\n        }} else {{\n            echo \"&lt;h1&gt;Please Log In&lt;/h1&gt;\";\n            if ($error_message) {{\n                echo \"&lt;p class='error'&gt;$error_message&lt;/p&gt;\";\n            }}\n            echo \"&lt;form method='post'&gt;\";\n            echo \"Username: &lt;input type='text' name='username'&gt;&lt;br&gt;\";\n            echo \"Password: &lt;input type='password' name='password'&gt;&lt;br&gt;\";\n            echo \"&lt;input type='submit' value='Log In'&gt;\";\n            echo \"&lt;/form&gt;\";\n        }}\n        ?&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nEOT\nchown apache:apache /var/www/html/index.php\nchmod 644 /var/www/html/index.php\nsystemctl restart httpd\necho \"User data script execution completed\"\n'''\n</code></pre> <pre><code># Create and launch the frontend EC2 instance with specified configuration\n\nweb_instance = ec2_resource.create_instances(\n    ImageId=ami_id,  # Amazon Linux 2 AMI ID (replace with the latest)\n    InstanceType='t3.micro',\n    MaxCount=1,\n    MinCount=1,\n    NetworkInterfaces=[{\n        'SubnetId': public_subnet_id,\n        'DeviceIndex': 0,\n        'AssociatePublicIpAddress': True,\n        'Groups': [value_store.get('frontend_sg_id')]\n    }],\n    UserData=frontend_user_data,\n    TagSpecifications=[\n        {\n            'ResourceType': 'instance',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': 'FrontendServer'\n                },\n            ]\n        },\n    ],\n    IamInstanceProfile={'Arn': instance_profile_arn}  # Use the Instance Profile ARN here\n)\nweb_id = web_instance[0].id\nprint(f\"Web server deployed with ID: {web_id}\")\n</code></pre> <pre><code># Wait for the instance to be running to get the IP addresses\nweb_instance[0].wait_until_running()\nweb_instance[0].reload()\n\n# Get private IP\nweb_private_ip = web_instance[0].private_ip_address\nprint(f\"Web server private IP: {web_private_ip}\")\n\n# Get public IP\nweb_public_ip = web_instance[0].public_ip_address\nif web_public_ip:\n    print(f\"Frontend Web server public IP: {web_public_ip}\")\nelse:\n    print(\"Frontend Web server does not have a public IP address.\")\n</code></pre>"},{"location":"lab3/zt-lab3/#access-the-ec2-fe-instances-menu-in-aws-management-console","title":"Access the EC2 - FE Instances Menu in AWS Management Console.","text":""},{"location":"lab3/zt-lab3/#it-should-look-like-below_10","title":"It should look like below:","text":""},{"location":"lab3/zt-lab3/#server-details-tab_1","title":"Server Details Tab","text":""},{"location":"lab3/zt-lab3/#server-security-tab_1","title":"Server Security Tab","text":""},{"location":"lab3/zt-lab3/#testing-the-traditionally-secured-system","title":"Testing the Traditionally-Secured System","text":"<p>Now that our system is set up, let's test it by accessing the web server.</p> <pre><code># Wait for a bit to ensure the servers are fully initialized\n\nimport time\nimport boto3\n\ndef wait_for_ec2_instances(instance_ids, region_name, timeout=300, interval=10):\n    \"\"\"\n    Waits for the given EC2 instances to pass system and instance status checks within a timeout period.\n\n    Args:\n        instance_ids (list): A list of EC2 instance IDs to check.\n        region_name (str): The AWS region where the instances are located.\n        timeout (int): The maximum time to wait (in seconds) before giving up.\n        interval (int): The time interval (in seconds) between status checks.\n\n    Returns:\n        bool: True if all instances pass system and instance checks within the timeout, False otherwise.\n    \"\"\"\n    ec2 = boto3.client('ec2', region_name=region_name)\n    start_time = time.time()\n\n    while time.time() - start_time &lt; timeout:\n        # Check the status of the EC2 instances\n        response = ec2.describe_instance_status(InstanceIds=instance_ids)\n\n        # Get the instance statuses\n        statuses = {instance['InstanceId']: {\n                        'instance_state': instance['InstanceState']['Name'],\n                        'system_status': instance['SystemStatus']['Status'],\n                        'instance_status': instance['InstanceStatus']['Status']\n                    }\n                    for instance in response['InstanceStatuses']}\n\n        # Check if all instances are 'running' and both system and instance checks are 'ok'\n\n\n        all_ready = all(\n            status['instance_state'] == 'running' and \n            status['system_status'] == 'ok' and \n            status['instance_status'] == 'ok'\n            for status in statuses.values()\n        )\n\n        if all_ready:\n            print(f\"All instances {instance_ids} are fully initialized and passed all checks.\")\n            return True\n\n        print(f\"Current statuses: {statuses}\")\n        print(f\"Waiting for EC2 instances {instance_ids} to pass system and instance checks...\")\n        time.sleep(interval)\n\n    print(f\"Timeout: EC2 instances {instance_ids} did not fully initialize within {timeout} seconds.\")\n    return False\n\n# IDs of front-end and back-end EC2 instances\nfrontend_instance_id = web_id  # Replace with your front-end instance ID\nbackend_instance_id = backend_id   # Replace with your back-end instance ID\nregion = 'us-west-2'  # Replace with your region\n\n# Wait for both front-end and back-end instances to be fully initialized\nif wait_for_ec2_instances([frontend_instance_id, backend_instance_id], region_name=region):\n    print(\"Both EC2 instances are fully initialized!\")\nelse:\n    print(\"One or both EC2 instances failed to fully initialize within the timeout.\")\n</code></pre> <pre><code># Access the frontend web server\n\nimport requests\nprint(f\"Frontend Web server public IP: {web_public_ip}\")\nprint(\"Accessing the web server:\")\nresponse = requests.get(f\"http://{web_public_ip}\")\nprint(response.text)\n</code></pre>"},{"location":"lab3/zt-lab3/#access-the-frontend-web-server-using-its-public-ip","title":"Access the Frontend Web Server using its Public IP","text":""},{"location":"lab3/zt-lab3/#it-should-look-like-below_11","title":"It should look like below:","text":""},{"location":"lab3/zt-lab3/#before-login","title":"Before Login","text":""},{"location":"lab3/zt-lab3/#after-login","title":"After Login","text":""},{"location":"lab3/zt-lab3/#conclusion","title":"Conclusion","text":"<p>In this lab, we've set up a traditionally-secured system in AWS and explored its components. The system functions are: 1. This system has the authenticate the user against the credentials in Secrets Manager 2. If credentials match, then access to the sensitive information is displayed 3. If credentials do not match, then access is denied</p> <p>This system is based on \"Trust and Verify\" model. Next we will explore the zero trust \"Never Trust. Always VeriSfy\" model.</p>"},{"location":"lab3/zt-lab3/#cleanup","title":"Cleanup","text":"<p>To avoid unnecessary charges, let's clean up our resources:</p> <pre><code>import boto3\nimport time\nimport botocore\n\n# Initialize AWS clients\nec2 = boto3.client('ec2')\nlambda_client = boto3.client('lambda')\napigateway = boto3.client('apigateway')\niam = boto3.client('iam')\n\ndef wait_for_deletion(resource_type, resource_id, check_function):\n    print(f\"Confirming deletion of {resource_type} {resource_id}...\")\n    max_attempts = 30\n    for _ in range(max_attempts):\n        try:\n            if not check_function(resource_id):\n                print(f\"{resource_type} {resource_id} has been deleted.\")\n                return True\n        except botocore.exceptions.ClientError as e:\n            if e.response['Error']['Code'] == 'InvalidVpcID.NotFound':\n                print(f\"{resource_type} {resource_id} has been deleted.\")\n                return True\n        print(f\"{resource_type} {resource_id} is still being deleted. Waiting...\")\n        time.sleep(10)\n    print(f\"Timeout waiting for {resource_type} {resource_id} to be deleted.\")\n    return False\n\n\ndef delete_ec2_instances():\n    print(\"Deleting EC2 instances...\")\n    response = ec2.describe_instances(\n        Filters=[{'Name': 'instance-state-name', 'Values': ['pending', 'running', 'stopping', 'stopped']}]\n    )\n    instance_ids = [instance['InstanceId'] for reservation in response['Reservations'] for instance in reservation['Instances']]\n    if instance_ids:\n        ec2.terminate_instances(InstanceIds=instance_ids)\n        waiter = ec2.get_waiter('instance_terminated')\n        waiter.wait(InstanceIds=instance_ids)\n    print(\"EC2 instances deleted.\")\n\ndef delete_security_groups():\n    print(\"Deleting security groups...\")\n    response = ec2.describe_security_groups()\n    for sg in response['SecurityGroups']:\n        if sg['GroupName'] != 'default':\n            try:\n                ec2.delete_security_group(GroupId=sg['GroupId'])\n                print(f\"Security group {sg['GroupId']} deleted.\")\n            except botocore.exceptions.ClientError as e:\n                print(f\"Error deleting security group {sg['GroupId']}: {e}\")\n    print(\"Security group deletion attempted.\")\n\ndef delete_nat_gateway():\n    print(\"Deleting NAT Gateways...\")\n    response = ec2.describe_nat_gateways()\n    for nat_gateway in response['NatGateways']:\n        ec2.delete_nat_gateway(NatGatewayId=nat_gateway['NatGatewayId'])\n        wait_for_deletion('NAT Gateway', nat_gateway['NatGatewayId'], \n                          lambda id: ec2.describe_nat_gateways(NatGatewayIds=[id])['NatGateways'][0]['State'] != 'deleted')\n\n    # Release Elastic IPs\n    response = ec2.describe_addresses()\n    for eip in response['Addresses']:\n        if 'AssociationId' not in eip:\n            ec2.release_address(AllocationId=eip['AllocationId'])\n    print(\"NAT Gateways deleted and Elastic IPs released.\")\n\ndef delete_internet_gateway():\n    print(\"Deleting Internet Gateways...\")\n    response = ec2.describe_internet_gateways()\n    for igw in response['InternetGateways']:\n        if igw['Attachments']:\n            ec2.detach_internet_gateway(InternetGatewayId=igw['InternetGatewayId'], VpcId=igw['Attachments'][0]['VpcId'])\n        ec2.delete_internet_gateway(InternetGatewayId=igw['InternetGatewayId'])\n    print(\"Internet Gateways deleted.\")\n\ndef delete_subnets():\n    print(\"Deleting subnets...\")\n    response = ec2.describe_subnets()\n    for subnet in response['Subnets']:\n        if not subnet['DefaultForAz']:\n            ec2.delete_subnet(SubnetId=subnet['SubnetId'])\n    print(\"Subnets deleted.\")\n\ndef delete_route_tables():\n    print(\"Deleting route tables...\")\n    response = ec2.describe_route_tables()\n    for rt in response['RouteTables']:\n        if not rt.get('Associations') or not any(assoc.get('Main') for assoc in rt.get('Associations')):\n            ec2.delete_route_table(RouteTableId=rt['RouteTableId'])\n    print(\"Route tables deleted.\")\n\ndef delete_vpc():\n    print(\"Deleting VPCs...\")\n    response = ec2.describe_vpcs()\n    for vpc in response['Vpcs']:\n        if not vpc['IsDefault']:\n            try:\n                print(f\"Attempting to delete VPC {vpc['VpcId']}...\")\n                ec2.delete_vpc(VpcId=vpc['VpcId'])\n                wait_for_deletion('VPC', vpc['VpcId'], \n                                  lambda id: bool(ec2.describe_vpcs(VpcIds=[id])['Vpcs']))\n            except botocore.exceptions.ClientError as e:\n                if e.response['Error']['Code'] == 'InvalidVpcID.NotFound':\n                    print(f\"VPC {vpc['VpcId']} has already been deleted.\")\n                else:\n                    print(f\"Error deleting VPC {vpc['VpcId']}: {e}\")\n                    print(\"Please check and manually delete any remaining resources in this VPC.\")\n    print(\"VPC deletion completed.\")\n\n\ndef delete_lambda_function():\n    print(\"Deleting Lambda functions...\")\n    lambda_functions = lambda_client.list_functions()\n    for function in lambda_functions['Functions']:\n        if function['FunctionName'].startswith('IdentityProviderFunction-'):\n            lambda_client.delete_function(FunctionName=function['FunctionName'])\n    print(\"Lambda functions deleted.\")\n\ndef delete_api_gateway():\n    print(\"Deleting API Gateway...\")\n    apis = apigateway.get_rest_apis()\n    for api in apis['items']:\n        if api['name'] == 'IdentityProviderApi':\n            apigateway.delete_rest_api(restApiId=api['id'])\n    print(\"API Gateway deleted.\")\n\ndef delete_iam_role():\n    print(\"Deleting IAM roles...\")\n    roles = iam.list_roles()\n    for role in roles['Roles']:\n        if role['RoleName'].startswith('LabLambdaExecutionRole-'):\n            attached_policies = iam.list_attached_role_policies(RoleName=role['RoleName'])\n            for policy in attached_policies['AttachedPolicies']:\n                iam.detach_role_policy(RoleName=role['RoleName'], PolicyArn=policy['PolicyArn'])\n            iam.delete_role(RoleName=role['RoleName'])\n    print(\"IAM roles deleted.\")\n\ndef cleanup():\n    delete_ec2_instances()\n    delete_nat_gateway()\n    delete_internet_gateway()\n    delete_subnets()\n    delete_route_tables()\n    delete_security_groups()\n    delete_vpc()\n    delete_lambda_function()\n    delete_api_gateway()\n    delete_iam_role()\n    print(\"Cleanup completed.\")\n\n# Run the cleanup\ncleanup()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"lab5/zt-lab5/","title":"Implementing Basic Zero Trust Network","text":""},{"location":"lab5/zt-lab5/#zero-trust-architecture-lab-5-basic-zero-trust-network-implementation","title":"Zero Trust Architecture Lab 5: Basic Zero Trust Network Implementation","text":""},{"location":"lab5/zt-lab5/#introduction","title":"Introduction","text":"<p>Welcome to Lab 5 of our Zero Trust Architecture course! In this lab, you will implement a basic Zero Trust network using AWS services. You'll set up a system that demonstrates core Zero Trust principles, including identity-based access control, least privilege access, and continuous authentication.</p> <p></p>"},{"location":"lab5/zt-lab5/#lab-overview","title":"Lab Overview","text":"<p>In this lab, you will:</p> <ol> <li>Set up a simple Identity Provider using AWS Lambda and API Gateway</li> <li>Create a VPC with public and private subnets</li> <li>Implement network security using Internet Gateway, NAT Gateway, and security groups</li> <li>Deploy a backend server with token-based access control</li> <li>Deploy a frontend server that authenticates users and mediates access to the backend</li> </ol>"},{"location":"lab5/zt-lab5/#key-components","title":"Key Components","text":"<ol> <li>Identity Provider: A Lambda function that generates and validates tokens</li> <li>VPC: A Virtual Private Cloud with public and private subnets</li> <li>Security Groups: FrontendSG and BackendSG to control network access</li> <li>Backend Server: An EC2 instance in the private subnet that checks for valid tokens</li> <li>Frontend Server: An EC2 instance in the public subnet that authenticates users and requests data from the backend</li> </ol>"},{"location":"lab5/zt-lab5/#lab-steps","title":"Lab Steps","text":"<ol> <li>Set up the AWS environment and initialize necessary clients</li> <li>Create an Identity Provider using Lambda and API Gateway</li> <li>Set up a VPC with public and private subnets</li> <li>Configure Internet Gateway, NAT Gateway, and route tables</li> <li>Create security groups for frontend and backend servers</li> <li>Deploy the backend server in the private subnet</li> <li>Deploy the frontend server in the public subnet</li> <li>Test the Zero Trust-secured system</li> </ol>"},{"location":"lab5/zt-lab5/#use-cases","title":"Use Cases","text":""},{"location":"lab5/zt-lab5/#use-case-1-successful-authentication-and-data-access","title":"Use Case 1: Successful Authentication and Data Access","text":"<p>Scenario: A legitimate user accesses the system with correct credentials.</p> <p>Steps: 1. Access the frontend server's public IP in a web browser 2. Enter the correct username (\"admin\") and password (\"password123\") 3. Observe the generated token and the sensitive data retrieved from the backend</p> <p>Learning Points: - Token-based authentication in action - Separation of authentication (frontend) and authorization (backend) - Secure communication between frontend and backend servers</p>"},{"location":"lab5/zt-lab5/#use-case-2-failed-authentication","title":"Use Case 2: Failed Authentication","text":"<p>Scenario: An attacker attempts to access the system with incorrect credentials.</p> <p>Steps: 1. Access the frontend server's public IP in a web browser 2. Enter an incorrect username or password 3. Observe the error message and lack of access to sensitive data</p> <p>Learning Points: - Importance of strong authentication in Zero Trust - How the system denies access without valid credentials</p>"},{"location":"lab5/zt-lab5/#use-case-3-token-expiration","title":"Use Case 3: Token Expiration","text":"<p>Scenario: A user's session expires, requiring re-authentication.</p> <p>Steps: 1. Authenticate successfully as in Use Case 1 2. Wait for the token to expire (set to 1 hour in this lab) 3. Attempt to access sensitive data again 4. Observe that you're redirected to the login page</p> <p>Learning Points: - Importance of short-lived tokens in Zero Trust - Continuous authentication principle</p>"},{"location":"lab5/zt-lab5/#use-case-4-attempting-direct-backend-access","title":"Use Case 4: Attempting Direct Backend Access","text":"<p>Scenario: An attacker attempts to bypass the frontend and access the backend directly.</p> <p>Steps: 1. Attempt to access the backend server's private IP directly 2. Observe that the connection times out</p> <p>Learning Points: - Importance of network segmentation in Zero Trust - How placing the backend in a private subnet enhances security</p>"},{"location":"lab5/zt-lab5/#use-case-5-modifying-the-token","title":"Use Case 5: Modifying the Token","text":"<p>Scenario: An attacker obtains a valid token and attempts to modify it.</p> <p>Steps: 1. Authenticate successfully and copy the generated token 2. Modify part of the token 3. Use developer tools to send a request to the backend with the modified token 4. Observe that the backend rejects the modified token</p> <p>Learning Points: - Importance of token integrity in Zero Trust - How the backend validates tokens independently</p>"},{"location":"lab5/zt-lab5/#reflection-questions","title":"Reflection Questions","text":"<ol> <li>How does this implementation enforce the \"never trust, always verify\" principle of Zero Trust?</li> <li>What are the benefits and potential drawbacks of using short-lived tokens for authentication?</li> <li>How does the network architecture (public/private subnets, NAT Gateway) contribute to the Zero Trust model?</li> <li>Can you think of ways to further enhance this system's security within the Zero Trust framework?</li> <li>How might this basic Zero Trust model need to be adapted for a large-scale, real-world application?</li> </ol> <p>By completing this lab and exploring these use cases, you'll gain hands-on experience with implementing and testing a basic Zero Trust Architecture, setting the foundation for more advanced Zero Trust concepts and implementations.</p>"},{"location":"lab5/zt-lab5/#identity-provider-setup","title":"Identity Provider Setup","text":"<p>This notebook sets up a simple identity provider using AWS Lambda and API Gateway.</p> <pre><code># Version 1.2\n# Import necessary libraries\n\nimport boto3\nimport json\nimport time\nimport random\nimport string\n</code></pre> <pre><code># Set the AWS region for resource creation (change as needed)\n\nregion = 'us-west-2'\n</code></pre> <pre><code># Initialize EC2 client and resource objects for interacting with AWS\n\nlambda_client = boto3.client('lambda', region_name=region)\niam_client = boto3.client('iam', region_name=region)\napigateway_client = boto3.client('apigateway', region_name=region)\n\nprint(f\"AWS environment initialized in region: {region}\")\n</code></pre> <pre><code>AWS environment initialized in region: us-west-2\n</code></pre> <pre><code># Function to generate a random string\n\ndef generate_random_string(length=10):\n    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))\n</code></pre>"},{"location":"lab5/zt-lab5/#step-1-create-iam-role-for-lambda","title":"Step 1: Create IAM Role for Lambda","text":"<pre><code># Initialize IAM client\niam_client = boto3.client('iam')\n\n# Function to generate a random string\n# def generate_random_string(length=10):\n#    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))\n\nprint(\"Creating IAM Role...\")\nassume_role_policy = {\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [{\n        \"Effect\": \"Allow\",\n        \"Principal\": {\"Service\": \"lambda.amazonaws.com\"},\n        \"Action\": \"sts:AssumeRole\"\n    }]\n}\n\nrole_name = f'LabLambdaExecutionRole-{generate_random_string()}'\nrole_response = iam_client.create_role(\n    RoleName=role_name,\n    AssumeRolePolicyDocument=json.dumps(assume_role_policy)\n)\n\niam_client.attach_role_policy(\n    RoleName=role_name,\n    PolicyArn='arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'\n)\n\n# Wait for role to be created\ntime.sleep(10)\nprint(f\"IAM Role created: {role_response['Role']['Arn']}\")\n</code></pre> <pre><code>Creating IAM Role...\nIAM Role created: arn:aws:iam::172872575382:role/LabLambdaExecutionRole-na1s9h99rx\n</code></pre>"},{"location":"lab5/zt-lab5/#step-2-create-lambda-function","title":"Step 2: Create Lambda Function","text":"<pre><code>import boto3\nimport json\nimport io\nimport zipfile\n\n# Initialize Lambda client\nlambda_client = boto3.client('lambda')\n\nprint(\"Creating Lambda Function...\")\nlambda_code = \"\"\"\nconst crypto = require('crypto');\n\nconst users = {\n    'admin': 'password123',\n    'user1': 'password456'\n};\n\nconst generateToken = (username) =&gt; {\n    const payload = {\n        username: username,\n        exp: Math.floor(Date.now() / 1000) + (60 * 60) // 1 hour expiration\n    };\n    return Buffer.from(JSON.stringify(payload)).toString('base64');\n};\n\nexports.handler = async (event) =&gt; {\n    const { username, password } = JSON.parse(event.body);\n    if (users[username] &amp;&amp; users[username] === password) {\n        const token = generateToken(username);\n        return {\n            statusCode: 200,\n            body: JSON.stringify({ token: token })\n        };\n    } else {\n        return {\n            statusCode: 401,\n            body: JSON.stringify({ message: 'Invalid credentials' })\n        };\n    }\n};\n\"\"\"\n\n# Create a ZIP file in memory\nzip_output = io.BytesIO()\nwith zipfile.ZipFile(zip_output, 'w', zipfile.ZIP_DEFLATED) as zip_file:\n    zip_file.writestr('index.js', lambda_code)\n\n# Seek to the beginning of the BytesIO object\nzip_output.seek(0)\n\nlambda_function_name = f'IdentityProviderFunction-{generate_random_string()}'\nlambda_response = lambda_client.create_function(\n    FunctionName=lambda_function_name,\n    Runtime='nodejs16.x',\n    Role=role_response['Role']['Arn'],\n    Handler='index.handler',\n    Code={'ZipFile': zip_output.read()},\n    Timeout=30\n)\n\nprint(f\"Lambda Function created: {lambda_response['FunctionArn']}\")\n</code></pre> <pre><code>Creating Lambda Function...\nLambda Function created: arn:aws:lambda:us-west-2:172872575382:function:IdentityProviderFunction-ztst5lvzjs\n</code></pre>"},{"location":"lab5/zt-lab5/#step-3-create-api-gateway","title":"Step 3: Create API Gateway","text":"<pre><code>print(\"Creating API Gateway...\")\napi_response = apigateway_client.create_rest_api(\n    name='IdentityProviderApi'\n)\n\nresources = apigateway_client.get_resources(restApiId=api_response['id'])\nroot_id = resources['items'][0]['id']\n\nresource_response = apigateway_client.create_resource(\n    restApiId=api_response['id'],\n    parentId=root_id,\n    pathPart='authenticate'\n)\n\napigateway_client.put_method(\n    restApiId=api_response['id'],\n    resourceId=resource_response['id'],\n    httpMethod='POST',\n    authorizationType='NONE'\n)\n\napigateway_client.put_integration(\n    restApiId=api_response['id'],\n    resourceId=resource_response['id'],\n    httpMethod='POST',\n    type='AWS_PROXY',\n    integrationHttpMethod='POST',\n    uri=f\"arn:aws:apigateway:{lambda_response['FunctionArn'].split(':')[3]}:lambda:path/2015-03-31/functions/{lambda_response['FunctionArn']}/invocations\"\n)\n</code></pre> <pre><code>Creating API Gateway...\n\n\n\n\n\n{'ResponseMetadata': {'RequestId': 'f1e56980-b892-4f45-9522-9f45e711b0f1',\n  'HTTPStatusCode': 201,\n  'HTTPHeaders': {'date': 'Sun, 02 Feb 2025 01:56:02 GMT',\n   'content-type': 'application/json',\n   'content-length': '318',\n   'connection': 'keep-alive',\n   'x-amzn-requestid': 'f1e56980-b892-4f45-9522-9f45e711b0f1',\n   'x-amz-apigw-id': 'FVWL9JHwPHcEb6w='},\n  'RetryAttempts': 0},\n 'type': 'AWS_PROXY',\n 'httpMethod': 'POST',\n 'uri': 'arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:172872575382:function:IdentityProviderFunction-ztst5lvzjs/invocations',\n 'passthroughBehavior': 'WHEN_NO_MATCH',\n 'timeoutInMillis': 29000,\n 'cacheNamespace': '4c9l54',\n 'cacheKeyParameters': []}\n</code></pre>"},{"location":"lab5/zt-lab5/#step-4-deploy-api","title":"Step 4: Deploy API","text":"<pre><code>print(\"Deploying API...\")\napigateway_client.create_deployment(\n    restApiId=api_response['id'],\n    stageName='prod'\n)\n</code></pre> <pre><code>Deploying API...\n\n\n\n\n\n{'ResponseMetadata': {'RequestId': '4099bd41-e716-4899-a91c-056246d5ee20',\n  'HTTPStatusCode': 201,\n  'HTTPHeaders': {'date': 'Sun, 02 Feb 2025 01:56:02 GMT',\n   'content-type': 'application/json',\n   'content-length': '41',\n   'connection': 'keep-alive',\n   'x-amzn-requestid': '4099bd41-e716-4899-a91c-056246d5ee20',\n   'x-amz-apigw-id': 'FVWL-KaVvHcEbbw='},\n  'RetryAttempts': 0},\n 'id': '46lm8x',\n 'createdDate': datetime.datetime(2025, 2, 2, 1, 56, 2, tzinfo=tzlocal())}\n</code></pre>"},{"location":"lab5/zt-lab5/#step-5-add-lambda-permission","title":"Step 5: Add Lambda Permission","text":"<pre><code>print(\"Adding Lambda Permission...\")\nlambda_client.add_permission(\n    FunctionName=lambda_response['FunctionName'],\n    StatementId='apigateway-invoke',\n    Action='lambda:InvokeFunction',\n    Principal='apigateway.amazonaws.com',\n    SourceArn=f\"arn:aws:execute-api:{lambda_response['FunctionArn'].split(':')[3]}:{lambda_response['FunctionArn'].split(':')[4]}:{api_response['id']}/*/*/authenticate\"\n)\n</code></pre> <pre><code>Adding Lambda Permission...\n\n\n\n\n\n{'ResponseMetadata': {'RequestId': 'e60ba71f-d694-494e-a78a-dffe41e99559',\n  'HTTPStatusCode': 201,\n  'HTTPHeaders': {'date': 'Sun, 02 Feb 2025 01:56:03 GMT',\n   'content-type': 'application/json',\n   'content-length': '385',\n   'connection': 'keep-alive',\n   'x-amzn-requestid': 'e60ba71f-d694-494e-a78a-dffe41e99559'},\n  'RetryAttempts': 0},\n 'Statement': '{\"Sid\":\"apigateway-invoke\",\"Effect\":\"Allow\",\"Principal\":{\"Service\":\"apigateway.amazonaws.com\"},\"Action\":\"lambda:InvokeFunction\",\"Resource\":\"arn:aws:lambda:us-west-2:172872575382:function:IdentityProviderFunction-ztst5lvzjs\",\"Condition\":{\"ArnLike\":{\"AWS:SourceArn\":\"arn:aws:execute-api:us-west-2:172872575382:7btkmuwh54/*/*/authenticate\"}}}'}\n</code></pre>"},{"location":"lab5/zt-lab5/#initialize-value-store","title":"Initialize Value Store","text":"<p>Initialize long-term storage</p> <pre><code>class ValueStore:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super(ValueStore, cls).__new__(cls)\n            cls._instance.store = {}\n        return cls._instance\n\n    def set(self, key, value):\n        self.store[key] = value\n\n    def get(self, key, default=None):\n        return self.store.get(key, default)\n\n    def print_all(self):\n        for key, value in self.store.items():\n            print(f\"{key}: {value}\")\n\n# Create a global instance\nvalue_store = ValueStore()\n\n# Test the ValueStore\nvalue_store.set('test_key', 'test_value')\nprint(value_store.get('test_key'))  # Should print: test_value\n</code></pre> <pre><code>test_value\n</code></pre>"},{"location":"lab5/zt-lab5/#output","title":"Output","text":"<pre><code># Output the API URL\napi_url = f\"https://{api_response['id']}.execute-api.{lambda_response['FunctionArn'].split(':')[3]}.amazonaws.com/prod/authenticate\"\nprint(f\"\\nIdentity Provider API URL: {api_url}\")\n\nprint(\"\\nSetup complete!\")\n\n# Store the api_url for later use\nidp_url = api_url\nvalue_store.set('idp_url',api_url)\n</code></pre> <pre><code>Identity Provider API URL: https://7btkmuwh54.execute-api.us-west-2.amazonaws.com/prod/authenticate\n\nSetup complete!\n</code></pre>"},{"location":"lab5/zt-lab5/#base-vpc-setup","title":"Base VPC Setup","text":"<p>This notebook sets up a base VPC.</p>"},{"location":"lab5/zt-lab5/#setup","title":"Setup","text":"<p>First, let's set up our AWS environment. Make sure you have configured your AWS CLI with the appropriate credentials.</p> <pre><code>import boto3\nimport json\nimport time\n</code></pre>"},{"location":"lab5/zt-lab5/#set-the-aws-region","title":"Set the AWS region","text":"<p>Configure the AWS region to create the network and servers</p> <pre><code># Set the AWS region for resource creation (change as needed)\n\nregion = 'us-west-2'\n</code></pre>"},{"location":"lab5/zt-lab5/#initialize-aws-clients","title":"Initialize AWS clients","text":"<p>Setup the necessary environment variables</p> <pre><code># Initialize EC2 client and resource objects for interacting with AWS\n\nec2_client = boto3.client('ec2', region_name=region)\nec2_resource = boto3.resource('ec2', region_name=region)\nsecretsmanager = boto3.client('secretsmanager', region_name=region)\niam = boto3.client('iam', region_name=region)\n\nprint(f\"AWS environment initialized in region: {region}\")\n</code></pre> <pre><code>AWS environment initialized in region: us-west-2\n</code></pre>"},{"location":"lab5/zt-lab5/#step-1-create-a-vpc-and-subnet","title":"Step 1: Create a VPC and Subnet","text":"<p>Let's start by creating our Virtual Private Cloud (VPC) and a public subnet.</p> <pre><code># Create VPC\n\nvpc_response = ec2_client.create_vpc(CidrBlock='10.0.0.0/16')\nvpc_id = vpc_response['Vpc']['VpcId']\nec2_client.create_tags(Resources=[vpc_id], Tags=[{'Key': 'Name', 'Value': 'ZTSecuredVPC'}])\n\nvalue_store.set('vpc_id', vpc_id)\n\nprint(f\"VPC created with ID: {vpc_id}\")\n</code></pre> <pre><code>VPC created with ID: vpc-0728e735804cc4e70\n</code></pre> <pre><code># Get available Availability Zones\n\navailable_azs = ec2_client.describe_availability_zones()['AvailabilityZones']\naz = available_azs[0]['ZoneName']  # Choose the first available AZ\n\n# Create Public subnet\n\npublic_subnet_response = ec2_client.create_subnet(\n    VpcId=value_store.get('vpc_id'),\n    CidrBlock='10.0.1.0/24',\n    AvailabilityZone=az,\n    TagSpecifications=[\n        {\n            'ResourceType': 'subnet',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': 'PublicSubnet'\n                }\n            ]\n        }\n    ]\n)\npublic_subnet_id = public_subnet_response['Subnet']['SubnetId']\nprint(f\"Public subnet created with ID: {public_subnet_id} in Availability Zone: {az}\")\n\n# Enable auto-assign public IP for the public subnet\nec2_client.modify_subnet_attribute(\n    SubnetId=public_subnet_id,\n    MapPublicIpOnLaunch={'Value': True}\n)\nprint(\"Auto-assign public IP enabled for the public subnet\")\n</code></pre> <pre><code>Public subnet created with ID: subnet-0985cd89c6c75a3a8 in Availability Zone: us-west-2a\nAuto-assign public IP enabled for the public subnet\n</code></pre> <pre><code># First, let's find the public subnet ID\npublic_subnets = ec2_client.describe_subnets(\n    Filters=[\n        {'Name': 'vpc-id', 'Values': [vpc_id]},\n        {'Name': 'tag:Name', 'Values': ['PublicSubnet']}\n    ]\n)['Subnets']\n\nif not public_subnets:\n    raise ValueError(\"No public subnet found. Please ensure you've created a public subnet with the tag 'Name: PublicSubnet'\")\n\npublic_subnet_id = public_subnets[0]['SubnetId']\npublic_subnet_az = public_subnets[0]['AvailabilityZone']\n\nprint(f\"Found public subnet with ID: {public_subnet_id} in Availability Zone: {public_subnet_az}\")\n\n# Now create the Private subnet in the same Availability Zone\nprivate_subnet_response = ec2_client.create_subnet(\n    VpcId=value_store.get('vpc_id'), \n    CidrBlock='10.0.2.0/24',  # Different CIDR block for the private subnet\n    AvailabilityZone=public_subnet_az,\n    TagSpecifications=[\n        {\n            'ResourceType': 'subnet',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': 'PrivateSubnet'\n                }\n            ]\n        }\n    ]\n)\nprivate_subnet_id = private_subnet_response['Subnet']['SubnetId']\nprint(f\"Private subnet created with ID: {private_subnet_id} in the same AZ as the public subnet: {public_subnet_az}\")\n\n# Modify the private subnet to disable auto-assign public IP\nec2_client.modify_subnet_attribute(SubnetId=private_subnet_id, MapPublicIpOnLaunch={'Value': False})\nprint(\"Auto-assign public IP disabled for the private subnet\")\n</code></pre> <pre><code>Found public subnet with ID: subnet-0985cd89c6c75a3a8 in Availability Zone: us-west-2a\nPrivate subnet created with ID: subnet-05d90edb0a0491089 in the same AZ as the public subnet: us-west-2a\nAuto-assign public IP disabled for the private subnet\n</code></pre>"},{"location":"lab5/zt-lab5/#step-2-set-up-internet-gateway","title":"Step 2: Set up Internet Gateway","text":"<p>Now, let's create an Internet Gateway.</p> <pre><code># Create Internet Gateway\nigw_name = \"ZTSecuredIGW\"\nigw_response = ec2_client.create_internet_gateway(\n    TagSpecifications=[\n        {\n            'ResourceType': 'internet-gateway',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': igw_name\n                }\n            ]\n        }\n    ]\n)\nigw_id = igw_response['InternetGateway']['InternetGatewayId']\nec2_client.attach_internet_gateway(InternetGatewayId=igw_id, VpcId=value_store.get('vpc_id'))\nprint(f\"Internet Gateway '{igw_name}' created and attached with ID: {igw_id}\")\n</code></pre> <pre><code>Internet Gateway 'ZTSecuredIGW' created and attached with ID: igw-07f367544383df930\n</code></pre>"},{"location":"lab5/zt-lab5/#step-3-set-up-nat-gateway","title":"Step 3: Set up NAT Gateway","text":"<p>Next, let's create a NAT Gateway (Network Address Translation) to give instances in private subnet access to the Internet.</p> <pre><code># Setup NAT Gateway\n# Note: This will take a few minutes\n\ndef setup_nat_gateway(vpc_id, public_subnet_id, nat_gateway_name=\"ZTNATGW\"):\n    # Create Elastic IP\n    eip = ec2_client.allocate_address(Domain='vpc')\n\n    # Create NAT Gateway with a name tag\n    nat_gateway = ec2_client.create_nat_gateway(\n        SubnetId=public_subnet_id,\n        AllocationId=eip['AllocationId'],\n        TagSpecifications=[\n            {\n                'ResourceType': 'natgateway',\n                'Tags': [\n                    {\n                        'Key': 'Name',\n                        'Value': nat_gateway_name\n                    }\n                ]\n            }\n        ]\n    )\n\n    # Wait for the NAT Gateway to be available\n    waiter = ec2_client.get_waiter('nat_gateway_available')\n    waiter.wait(\n        NatGatewayIds=[nat_gateway['NatGateway']['NatGatewayId']],\n        WaiterConfig={'Delay': 30, 'MaxAttempts': 10}\n    )\n\n    print(f\"NAT Gateway '{nat_gateway_name}' created with ID: {nat_gateway['NatGateway']['NatGatewayId']}\")\n    return nat_gateway['NatGateway']['NatGatewayId']\n\n# Create the NAT Gateway\nnat_gateway_id = setup_nat_gateway(value_store.get('vpc_id'), public_subnet_id)\nprint(f\"NAT Gateway setup complete with ID: {nat_gateway_id}\")\n</code></pre> <pre><code>NAT Gateway 'ZTNATGW' created with ID: nat-0f6054636ced46034\nNAT Gateway setup complete with ID: nat-0f6054636ced46034\n</code></pre> <pre><code># Create and configure Public route table\n\nrt_name = \"ZTPublicRT\"\nrt_response = ec2_client.create_route_table(\n    VpcId=value_store.get('vpc_id'),\n    TagSpecifications=[\n        {\n            'ResourceType': 'route-table',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': rt_name\n                }\n            ]\n        }\n    ]\n)\nrt_id = rt_response['RouteTable']['RouteTableId']\n\n# Create route to Internet Gateway\nec2_client.create_route(RouteTableId=rt_id, DestinationCidrBlock='0.0.0.0/0', GatewayId=igw_id)\n\n# Associate route table with subnet\nec2_client.associate_route_table(RouteTableId=rt_id, SubnetId=public_subnet_id)\n\nprint(f\"Route table '{rt_name}' created and configured with ID: {rt_id}\")\n</code></pre> <pre><code>Route table 'ZTPublicRT' created and configured with ID: rtb-0a513037ab63a2104\n</code></pre> <pre><code># Create and configure Private route table\n\nprivate_rt_name = \"ZTPrivateRT\"\nprivate_rt_response = ec2_client.create_route_table(\n    VpcId=value_store.get('vpc_id'),\n    TagSpecifications=[\n        {\n            'ResourceType': 'route-table',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': private_rt_name\n                }\n            ]\n        }\n    ]\n)\nprivate_rt_id = private_rt_response['RouteTable']['RouteTableId']\n\n# Create route to NAT Gateway\nec2_client.create_route(\n    RouteTableId=private_rt_id, \n    DestinationCidrBlock='0.0.0.0/0', \n    NatGatewayId=nat_gateway_id\n)\n\n# Associate route table with private subnet\nec2_client.associate_route_table(RouteTableId=private_rt_id, SubnetId=private_subnet_id)\n\nprint(f\"Private route table '{private_rt_name}' created and configured with ID: {private_rt_id}\")\n\n# Optionally, you can describe the route table to verify its configuration\nroutes = ec2_client.describe_route_tables(RouteTableIds=[private_rt_id])\nprint(f\"Routes in the private route table: {routes['RouteTables'][0]['Routes']}\")\n</code></pre> <pre><code>Private route table 'ZTPrivateRT' created and configured with ID: rtb-0a0fbbcf41bf03337\nRoutes in the private route table: [{'DestinationCidrBlock': '10.0.0.0/16', 'GatewayId': 'local', 'Origin': 'CreateRouteTable', 'State': 'active'}, {'DestinationCidrBlock': '0.0.0.0/0', 'NatGatewayId': 'nat-0f6054636ced46034', 'Origin': 'CreateRoute', 'State': 'active'}]\n</code></pre>"},{"location":"lab5/zt-lab5/#step-4-create-an-zero-trust-security-groups","title":"Step 4: Create an Zero Trust Security Groups","text":"<p>Let's create a security group that allows for following: 1. FrontendSG: Allow traffic to port 80 from all locations 2. BackendSG: Allow traffic to port 80 from instance that is assigned FrontendSG</p> <pre><code>import boto3\nec2_client = boto3.client('ec2')\n\ndef create_security_groups(vpc_id):\n    # FRONTEND SECURITY GROUP\n    # Create Web Server Security Group\n    frontend_sg = ec2_client.create_security_group(\n        GroupName='FrontendSG',\n        Description='Allow HTTP access to web server',\n        VpcId=vpc_id\n    )\n    frontend_sg_id = frontend_sg['GroupId']\n\n    # Add Name tag to Frontend Security Group\n    ec2_client.create_tags(\n        Resources=[frontend_sg_id],\n        Tags=[{'Key': 'Name', 'Value': 'FrontendSG'}]\n    )\n\n    # Add inbound rule to allow HTTP traffic from anywhere\n    ec2_client.authorize_security_group_ingress(\n        GroupId=frontend_sg_id,\n        IpPermissions=[\n            {'IpProtocol': 'tcp', 'FromPort': 80, 'ToPort': 80, 'IpRanges': [{'CidrIp': '0.0.0.0/0'}]}\n        ]\n    )\n\n    # BACKEND SECURITY GROUP\n    # Create Backend Server Security Group\n    backend_sg = ec2_client.create_security_group(\n        GroupName='BackendSG',\n        Description='Allow access from web server to backend server',\n        VpcId=vpc_id\n    )\n    backend_sg_id = backend_sg['GroupId']\n\n    # Add Name tag to Backend Security Group\n    ec2_client.create_tags(\n        Resources=[backend_sg_id],\n        Tags=[{'Key': 'Name', 'Value': 'BackendSG'}]\n    )\n\n    # Add inbound rule to allow all TCP traffic from the frontend security group\n    ec2_client.authorize_security_group_ingress(\n        GroupId=backend_sg_id,\n        IpPermissions=[\n            {'IpProtocol': 'tcp', 'FromPort': 0, 'ToPort': 65535, 'UserIdGroupPairs': [{'GroupId': frontend_sg_id}]}\n        ]\n    )\n    value_store.set('frontend_sg_id', frontend_sg_id)\n    value_store.set('backend_sg_id', backend_sg_id)\n\n    print(f\"Frontend Server Security Group ID: {frontend_sg_id}\")\n    print(f\"Backend Server Security Group ID: {backend_sg_id}\")\n    return frontend_sg_id, backend_sg_id\n\n# Usage example\nweb_sg_id, backend_sg_id = create_security_groups(value_store.get('vpc_id'))\n</code></pre> <pre><code>Frontend Server Security Group ID: sg-07c0dafa87d5bedc6\nBackend Server Security Group ID: sg-0a1806b633bc068de\n</code></pre>"},{"location":"lab5/zt-lab5/#frontend-and-backend-servers-setup","title":"Frontend and Backend Servers Setup","text":"<p>This notebook sets up the frontend and backend servers.</p>"},{"location":"lab5/zt-lab5/#step-1-deploy-backend-server","title":"Step 1: Deploy Backend Server","text":"<p>Now, let's deploy our backend server with a mock sensitive database.</p> <pre><code># Function to fetch the latest Amazon Linux 2 AMI ID with error handling and fallback\n\ndef get_latest_amazon_linux_2_ami():\n    try:\n        response = ec2_client.describe_images(\n            Owners=['amazon'],\n            Filters=[\n                {'Name': 'name', 'Values': ['amzn2-ami-hvm-*-x86_64-gp2']},\n                {'Name': 'state', 'Values': ['available']}\n            ]\n        )\n\n        if not response['Images']:\n            print(\"No Amazon Linux 2 AMIs found. Falling back to a default AMI ID.\")\n            return 'ami-0caa0a2e2a99b8b82'  # This is a fallback AMI ID, replace with a known good one for your region\n\n        # Sort the images by creation date\n        sorted_images = sorted(response['Images'], key=lambda x: x['CreationDate'], reverse=True)\n        latest_ami_id = sorted_images[0]['ImageId']\n        print(f\"Latest Amazon Linux 2 AMI ID: {latest_ami_id}\")\n        return latest_ami_id\n\n    except Exception as e:\n        print(f\"An error occurred while fetching the latest AMI: {str(e)}\")\n        print(\"Falling back to a default AMI ID.\")\n        return 'ami-0caa0a2e2a99b8b82'  # This is a fallback AMI ID, replace with a known good one for your region\n\n# Get the latest Amazon Linux 2 AMI ID\nami_id = get_latest_amazon_linux_2_ami()\nprint(f\"Using AMI ID: {ami_id}\")\n</code></pre> <pre><code>Latest Amazon Linux 2 AMI ID: ami-0d7d857b0b59e8d60\nUsing AMI ID: ami-0d7d857b0b59e8d60\n</code></pre> <pre><code># User data script for backend instance setup: installs and configures Apache with PHP\n\nbackend_user_data = '''#!/bin/bash\nyum update -y\nyum install -y httpd php\nsystemctl start httpd\nsystemctl enable httpd\ncat &lt;&lt;'EOT' &gt; /var/www/html/api.php\n&lt;?php\nheader('Content-Type: application/json');\n$headers = getallheaders();\nif (!isset($headers['Authorization'])) {\n  http_response_code(401);\n  echo json_encode(['error' =&gt; 'No token provided']);\n  exit;\n}\n$token = $headers['Authorization'];\n$payload = json_decode(base64_decode($token), true);\nif (!$payload || !isset($payload['exp']) || $payload['exp'] &lt; time()) {\n  http_response_code(401);\n  echo json_encode(['error' =&gt; 'Invalid or expired token']);\n  exit;\n}\necho json_encode(['sensitive' =&gt; 'This is sensitive data from the backend', 'user' =&gt; $payload['username']]);\n?&gt;\nEOT\nchown apache:apache /var/www/html/api.php\nchmod 644 /var/www/html/api.php\nsystemctl restart httpd\n'''\n</code></pre> <pre><code># Create and launch the backend EC2 instance with specified configuration\n# Only assign Private IP\n\nbackend_instance = ec2_resource.create_instances(\n    ImageId=ami_id,  # Amazon Linux 2 AMI ID (replace with the latest)\n    InstanceType='t3.micro',\n    MaxCount=1,\n    MinCount=1,\n    NetworkInterfaces=[{\n        'SubnetId': private_subnet_id,\n        'DeviceIndex': 0,\n        'AssociatePublicIpAddress': False,\n        'Groups': [value_store.get('backend_sg_id')]\n    }],\n    UserData=backend_user_data,\n    TagSpecifications=[\n        {\n            'ResourceType': 'instance',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': 'BackendServer'\n                },\n            ]\n        },\n    ]\n)\nbackend_id = backend_instance[0].id\nprint(f\"Backend server deployed with ID: {backend_id}\")\n</code></pre> <pre><code>Backend server deployed with ID: i-00228d5cfd5aadb7b\n</code></pre> <pre><code># Wait for the instance to be running to get the IP addresses\nbackend_instance[0].wait_until_running()\nbackend_instance[0].reload()\n\n# Get private IP\nbackend_private_ip = backend_instance[0].private_ip_address\nvalue_store.set('backend_private_ip', backend_private_ip)\nprint(f\"Backend server private IP: {backend_private_ip}\")\n\n# Get public IP if it exists\nbackend_public_ip = backend_instance[0].public_ip_address\nif backend_public_ip:\n    print(f\"Backend server public IP: {backend_public_ip}\")\nelse:\n    print(\"Backend server does not have a public IP address.\")\n</code></pre> <pre><code>Backend server private IP: 10.0.2.229\nBackend server does not have a public IP address.\n</code></pre>"},{"location":"lab5/zt-lab5/#step-2-deploy-frontend-web-server","title":"Step 2: Deploy Frontend Web Server","text":"<p>Finally, let's deploy our public-facing web server.</p> <pre><code>idp_url = value_store.get('idp_url')\nbackend_private_ip = value_store.get('backend_private_ip')\n\n# User data script for frontend instance setup: installs and configures Apache with PHP\n# Create a simple login screen that will verify the credentials with Secrets Manager\n\nfrontend_user_data = f'''#!/bin/bash\nyum update -y\nyum install -y httpd php php-curl\nsystemctl start httpd\nsystemctl enable httpd\necho \"date.timezone = America/New_York\" &gt;&gt; /etc/php.ini\ncat &lt;&lt;EOT &gt; /var/www/html/index.php\n&lt;?php\nerror_reporting(E_ALL);\nini_set('display_errors', 1);\nsession_start();\n\n\\$identity_provider_url = '{value_store.get('idp_url')}';\n\\$backend_ip = '{value_store.get('backend_private_ip')}';\n\\$error_message = '';\n\nif (isset(\\$_GET['reset_session'])) {{\n    session_unset();\n    session_destroy();\n    header(\"Location: index.php\");\n    exit();\n}}\n\nif (\\$_SERVER['REQUEST_METHOD'] === 'POST') {{\n    if (isset(\\$_POST['username']) &amp;&amp; isset(\\$_POST['password'])) {{\n        \\$ch = curl_init(\\$identity_provider_url);\n        curl_setopt(\\$ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt(\\$ch, CURLOPT_POST, true);\n        curl_setopt(\\$ch, CURLOPT_POSTFIELDS, json_encode([\n            'username' =&gt; \\$_POST['username'],\n            'password' =&gt; \\$_POST['password']\n        ]));\n        curl_setopt(\\$ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);\n        \\$response = curl_exec(\\$ch);\n        \\$status_code = curl_getinfo(\\$ch, CURLINFO_HTTP_CODE);\n        curl_close(\\$ch);\n\n        if (\\$status_code === 200) {{\n            \\$result = json_decode(\\$response, true);\n            \\$_SESSION['token'] = \\$result['token'];\n        }} else {{\n            \\$error_message = 'Invalid username or password. Please try again.';\n        }}\n    }}\n}}\n\nif (isset(\\$_SESSION['token'])) {{\n    \\$backend_url = \"http://\\$backend_ip/api.php\";\n    \\$ch = curl_init(\\$backend_url);\n    curl_setopt(\\$ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt(\\$ch, CURLOPT_HTTPHEADER, [\n        \"Authorization: \" . \\$_SESSION['token']\n    ]);\n    \\$response = curl_exec(\\$ch);\n    \\$status_code = curl_getinfo(\\$ch, CURLINFO_HTTP_CODE);\n    curl_close(\\$ch);\n\n    if (\\$status_code === 200) {{\n        \\$data = json_decode(\\$response, true);\n        echo \"&lt;h1&gt;Welcome to our Secure Web Server!&lt;/h1&gt;\";\n        echo \"&lt;h2&gt;Your Session Token:&lt;/h2&gt;\";\n        echo \"&lt;pre&gt;\" . \\$_SESSION['token'] . \"&lt;/pre&gt;\";\n        echo \"&lt;h2&gt;Data from backend:&lt;/h2&gt;\";\n        echo \"&lt;pre&gt;\" . print_r(\\$data, true) . \"&lt;/pre&gt;\";\n        echo \"&lt;p&gt;&lt;a href='?reset_session=1'&gt;Reset Session&lt;/a&gt;&lt;/p&gt;\";\n    }} else {{\n        echo \"&lt;h1&gt;Error connecting to backend server&lt;/h1&gt;\";\n        echo \"&lt;p&gt;Please check the backend server configuration.&lt;/p&gt;\";\n        echo \"&lt;p&gt;&lt;a href='?reset_session=1'&gt;Reset Session&lt;/a&gt;&lt;/p&gt;\";\n    }}\n}} else {{\n    echo \"&lt;h1&gt;Please Log In&lt;/h1&gt;\";\n    if (\\$error_message) {{\n        echo \"&lt;p style='color: red;'&gt;\\$error_message&lt;/p&gt;\";\n    }}\n    echo \"&lt;form method='post'&gt;\";\n    echo \"Username: &lt;input type='text' name='username'&gt;&lt;br&gt;\";\n    echo \"Password: &lt;input type='password' name='password'&gt;&lt;br&gt;\";\n    echo \"&lt;input type='submit' value='Log In'&gt;\";\n    echo \"&lt;/form&gt;\";\n}}\n?&gt;\nEOT\nchown apache:apache /var/www/html/index.php\nchmod 644 /var/www/html/index.php\nsystemctl restart httpd\n'''\n</code></pre> <pre><code># Confirm the input variables\n\nprint(value_store.get('idp_url'))\nprint(value_store.get('backend_private_ip'))\n</code></pre> <pre><code>https://7btkmuwh54.execute-api.us-west-2.amazonaws.com/prod/authenticate\n10.0.2.229\n</code></pre> <pre><code># Create and launch the frontend EC2 instance with specified configuration\n\nweb_instance = ec2_resource.create_instances(\n    ImageId=ami_id,  # Amazon Linux 2 AMI ID (replace with the latest)\n    InstanceType='t3.micro',\n    MaxCount=1,\n    MinCount=1,\n    NetworkInterfaces=[{\n        'SubnetId': public_subnet_id,\n        'DeviceIndex': 0,\n        'AssociatePublicIpAddress': True,\n        'Groups': [value_store.get('frontend_sg_id')]\n    }],\n    UserData=frontend_user_data,\n    TagSpecifications=[\n        {\n            'ResourceType': 'instance',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': 'FrontendServer'\n                },\n            ]\n        },\n    ],\n)\nweb_id = web_instance[0].id\nprint(f\"Web server deployed with ID: {web_id}\")\n</code></pre> <pre><code>Web server deployed with ID: i-00ba47e8a5391b8fe\n</code></pre> <pre><code># Wait for the instance to be running to get the IP addresses\nweb_instance[0].wait_until_running()\nweb_instance[0].reload()\n\n# Get private IP\nweb_private_ip = web_instance[0].private_ip_address\nprint(f\"Web server private IP: {web_private_ip}\")\n\n# Get public IP\nweb_public_ip = web_instance[0].public_ip_address\nif web_public_ip:\n    print(f\"Frontend Web server public IP: {web_public_ip}\")\nelse:\n    print(\"Frontend Web server does not have a public IP address.\")\n</code></pre> <pre><code>Web server private IP: 10.0.1.71\nFrontend Web server public IP: 34.220.206.226\n</code></pre>"},{"location":"lab5/zt-lab5/#testing-the-zero-trust-secured-system","title":"Testing the Zero Trust-Secured System","text":"<p>Now that our system is set up, let's test it by accessing the web server.</p> <pre><code># Wait for a bit to ensure the servers are fully initialized\n\nimport time\nimport boto3\n\ndef wait_for_ec2_instances(instance_ids, region_name, timeout=300, interval=10):\n    \"\"\"\n    Waits for the given EC2 instances to pass system and instance status checks within a timeout period.\n\n    Args:\n        instance_ids (list): A list of EC2 instance IDs to check.\n        region_name (str): The AWS region where the instances are located.\n        timeout (int): The maximum time to wait (in seconds) before giving up.\n        interval (int): The time interval (in seconds) between status checks.\n\n    Returns:\n        bool: True if all instances pass system and instance checks within the timeout, False otherwise.\n    \"\"\"\n    ec2 = boto3.client('ec2', region_name=region_name)\n    start_time = time.time()\n\n    while time.time() - start_time &lt; timeout:\n        # Check the status of the EC2 instances\n        response = ec2.describe_instance_status(InstanceIds=instance_ids)\n\n        # Get the instance statuses\n        statuses = {instance['InstanceId']: {\n                        'instance_state': instance['InstanceState']['Name'],\n                        'system_status': instance['SystemStatus']['Status'],\n                        'instance_status': instance['InstanceStatus']['Status']\n                    }\n                    for instance in response['InstanceStatuses']}\n\n        # Check if all instances are 'running' and both system and instance checks are 'ok'\n\n\n        all_ready = all(\n            status['instance_state'] == 'running' and \n            status['system_status'] == 'ok' and \n            status['instance_status'] == 'ok'\n            for status in statuses.values()\n        )\n\n        if all_ready:\n            print(f\"All instances {instance_ids} are fully initialized and passed all checks.\")\n            return True\n\n        print(f\"Current statuses: {statuses}\")\n        print(f\"Waiting for EC2 instances {instance_ids} to pass system and instance checks...\")\n        time.sleep(interval)\n\n    print(f\"Timeout: EC2 instances {instance_ids} did not fully initialize within {timeout} seconds.\")\n    return False\n\n# IDs of front-end and back-end EC2 instances\nfrontend_instance_id = web_id  # Replace with your front-end instance ID\nbackend_instance_id = backend_id   # Replace with your back-end instance ID\nregion = 'us-west-2'  # Replace with your region\n\n# Wait for both front-end and back-end instances to be fully initialized\nif wait_for_ec2_instances([frontend_instance_id, backend_instance_id], region_name=region):\n    print(\"Both EC2 instances are fully initialized!\")\nelse:\n    print(\"One or both EC2 instances failed to fully initialize within the timeout.\")\n</code></pre> <pre><code>Current statuses: {'i-00ba47e8a5391b8fe': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}, 'i-00228d5cfd5aadb7b': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}}\nWaiting for EC2 instances ['i-00ba47e8a5391b8fe', 'i-00228d5cfd5aadb7b'] to pass system and instance checks...\nCurrent statuses: {'i-00ba47e8a5391b8fe': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}, 'i-00228d5cfd5aadb7b': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}}\nWaiting for EC2 instances ['i-00ba47e8a5391b8fe', 'i-00228d5cfd5aadb7b'] to pass system and instance checks...\nCurrent statuses: {'i-00ba47e8a5391b8fe': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}, 'i-00228d5cfd5aadb7b': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}}\nWaiting for EC2 instances ['i-00ba47e8a5391b8fe', 'i-00228d5cfd5aadb7b'] to pass system and instance checks...\nCurrent statuses: {'i-00ba47e8a5391b8fe': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}, 'i-00228d5cfd5aadb7b': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}}\nWaiting for EC2 instances ['i-00ba47e8a5391b8fe', 'i-00228d5cfd5aadb7b'] to pass system and instance checks...\nCurrent statuses: {'i-00ba47e8a5391b8fe': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}, 'i-00228d5cfd5aadb7b': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}}\nWaiting for EC2 instances ['i-00ba47e8a5391b8fe', 'i-00228d5cfd5aadb7b'] to pass system and instance checks...\nCurrent statuses: {'i-00ba47e8a5391b8fe': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}, 'i-00228d5cfd5aadb7b': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}}\nWaiting for EC2 instances ['i-00ba47e8a5391b8fe', 'i-00228d5cfd5aadb7b'] to pass system and instance checks...\nCurrent statuses: {'i-00ba47e8a5391b8fe': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}, 'i-00228d5cfd5aadb7b': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}}\nWaiting for EC2 instances ['i-00ba47e8a5391b8fe', 'i-00228d5cfd5aadb7b'] to pass system and instance checks...\nCurrent statuses: {'i-00ba47e8a5391b8fe': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}, 'i-00228d5cfd5aadb7b': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}}\nWaiting for EC2 instances ['i-00ba47e8a5391b8fe', 'i-00228d5cfd5aadb7b'] to pass system and instance checks...\nCurrent statuses: {'i-00ba47e8a5391b8fe': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}, 'i-00228d5cfd5aadb7b': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}}\nWaiting for EC2 instances ['i-00ba47e8a5391b8fe', 'i-00228d5cfd5aadb7b'] to pass system and instance checks...\nCurrent statuses: {'i-00ba47e8a5391b8fe': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}, 'i-00228d5cfd5aadb7b': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}}\nWaiting for EC2 instances ['i-00ba47e8a5391b8fe', 'i-00228d5cfd5aadb7b'] to pass system and instance checks...\nCurrent statuses: {'i-00ba47e8a5391b8fe': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}, 'i-00228d5cfd5aadb7b': {'instance_state': 'running', 'system_status': 'initializing', 'instance_status': 'initializing'}}\nWaiting for EC2 instances ['i-00ba47e8a5391b8fe', 'i-00228d5cfd5aadb7b'] to pass system and instance checks...\nAll instances ['i-00ba47e8a5391b8fe', 'i-00228d5cfd5aadb7b'] are fully initialized and passed all checks.\nBoth EC2 instances are fully initialized!\n</code></pre> <pre><code># Access the frontend web server\n\nimport requests\nprint(f\"Frontend Web server public IP: {web_public_ip}\")\nprint(\"Accessing the web server:\")\nresponse = requests.get(f\"http://{web_public_ip}\")\nprint(response.text)\n</code></pre> <pre><code>Frontend Web server public IP: 34.220.206.226\nAccessing the web server:\n&lt;h1&gt;Please Log In&lt;/h1&gt;&lt;form method='post'&gt;Username: &lt;input type='text' name='username'&gt;&lt;br&gt;Password: &lt;input type='password' name='password'&gt;&lt;br&gt;&lt;input type='submit' value='Log In'&gt;&lt;/form&gt;\n</code></pre>"},{"location":"lab5/zt-lab5/#clean-up-the-lab","title":"Clean Up the Lab","text":"<p>Clean up the lab environment and resources</p> <pre><code>import boto3\nimport time\nimport botocore\nimport random\nimport requests\n\n# Identify the role assigned to the sagemaker jupyter notebook\ndef get_current_sagemaker_role():\n    \"\"\"\n    Automatically retrieve the IAM role attached to the running SageMaker Notebook instance.\n    \"\"\"\n    try:\n        # Get the notebook instance name from the SageMaker Notebook Metadata API\n        metadata_file = \"/opt/ml/metadata/resource-metadata.json\"\n        with open(metadata_file, \"r\") as f:\n            metadata = json.load(f)\n            notebook_instance_name = metadata[\"ResourceName\"]  # Fetching notebook instance name\n\n        # Fetch the IAM role from SageMaker\n        sagemaker = boto3.client('sagemaker')\n        response = sagemaker.describe_notebook_instance(NotebookInstanceName=notebook_instance_name)\n        notebook_role_arn = response['RoleArn']\n        notebook_role_name = notebook_role_arn.split('/')[-1]  # Extract role name from ARN\n\n        print(f\"The SageMaker Notebook is using the IAM role: {notebook_role_name}\")\n        return notebook_role_name\n\n    except (botocore.exceptions.ClientError, FileNotFoundError, json.JSONDecodeError) as e:\n        print(f\"Error fetching SageMaker Notebook role: {e}\")\n        return None  # Return None if unable to fetch the role\n\n\n# Initialize AWS clients\nec2 = boto3.client('ec2')\nlambda_client = boto3.client('lambda')\napigateway = boto3.client('apigateway')\niam = boto3.client('iam')\n\ndef wait_for_deletion(resource_type, resource_id, check_function, error_codes=None):\n    print(f\"Confirming deletion of {resource_type} {resource_id}...\")\n    max_attempts = 30\n    error_codes = error_codes or []\n\n    for _ in range(max_attempts):\n        try:\n            if not check_function(resource_id):\n                print(f\"{resource_type} {resource_id} has been deleted.\")\n                return True\n        except botocore.exceptions.ClientError as e:\n            if e.response['Error']['Code'] in error_codes:\n                print(f\"{resource_type} {resource_id} has been deleted.\")\n                return True\n        print(f\"{resource_type} {resource_id} is still being deleted. Waiting...\")\n        time.sleep(10)\n    print(f\"Timeout waiting for {resource_type} {resource_id} to be deleted.\")\n    return False\n\ndef delete_network_interfaces():\n    print(\"Deleting Network Interfaces (ENIs)...\")\n    response = ec2.describe_network_interfaces()\n    for eni in response['NetworkInterfaces']:\n        try:\n            ec2.delete_network_interface(NetworkInterfaceId=eni['NetworkInterfaceId'])\n            print(f\"Deleted ENI {eni['NetworkInterfaceId']}\")\n        except botocore.exceptions.ClientError as e:\n            print(f\"Error deleting ENI {eni['NetworkInterfaceId']}: {e}\")\n    print(\"Network Interfaces deletion attempted.\")\n\ndef delete_security_groups():\n    print(\"Deleting security groups...\")\n\n    # Ensure no ENIs depend on security groups\n    delete_network_interfaces()\n\n    response = ec2.describe_security_groups()\n    for sg in response['SecurityGroups']:\n        if sg['GroupName'] != 'default':\n            try:\n                ec2.delete_security_group(GroupId=sg['GroupId'])\n                print(f\"Security group {sg['GroupId']} deleted.\")\n            except botocore.exceptions.ClientError as e:\n                print(f\"Error deleting security group {sg['GroupId']}: {e}\")\n    print(\"Security group deletion attempted.\")\n\ndef delete_ec2_instances():\n    print(\"Deleting EC2 instances...\")\n    response = ec2.describe_instances(\n        Filters=[{'Name': 'instance-state-name', 'Values': ['pending', 'running', 'stopping', 'stopped']}]\n    )\n    instance_ids = [instance['InstanceId'] for reservation in response['Reservations'] for instance in reservation['Instances']]\n    if instance_ids:\n        ec2.terminate_instances(InstanceIds=instance_ids)\n        waiter = ec2.get_waiter('instance_terminated')\n        waiter.wait(InstanceIds=instance_ids)\n    print(\"EC2 instances deleted.\")\n\ndef delete_nat_gateway():\n    print(\"Deleting NAT Gateways...\")\n    response = ec2.describe_nat_gateways()\n\n    for nat_gateway in response['NatGateways']:\n        nat_gateway_id = nat_gateway['NatGatewayId']\n\n        # Initiate deletion\n        ec2.delete_nat_gateway(NatGatewayId=nat_gateway_id)\n        print(f\"Initiated deletion of NAT Gateway {nat_gateway_id}...\")\n\n        # Wait for deletion to complete\n        max_attempts = 30\n        for attempt in range(max_attempts):\n            try:\n                response = ec2.describe_nat_gateways(NatGatewayIds=[nat_gateway_id])\n                state = response['NatGateways'][0]['State']\n\n                if state == 'deleted':\n                    print(f\"NAT Gateway {nat_gateway_id} has been deleted.\")\n                    break  # Exit loop immediately\n\n                print(f\"NAT Gateway {nat_gateway_id} is still in state '{state}'. Waiting...\")\n                time.sleep(10)\n\n            except botocore.exceptions.ClientError as e:\n                if e.response['Error']['Code'] == 'NatGatewayNotFound':\n                    print(f\"NAT Gateway {nat_gateway_id} no longer exists.\")\n                    break  # Exit loop if NAT Gateway is completely removed\n                else:\n                    print(f\"Error checking NAT Gateway {nat_gateway_id}: {e}\")\n                    break\n\n    # Release Elastic IPs\n    response = ec2.describe_addresses()\n    for eip in response['Addresses']:\n        if 'AssociationId' not in eip:\n            ec2.release_address(AllocationId=eip['AllocationId'])\n            print(f\"Elastic IP {eip['AllocationId']} released.\")\n\n    print(\"NAT Gateways deleted and Elastic IPs released.\")\n\ndef delete_internet_gateway():\n    print(\"Deleting Internet Gateways...\")\n    response = ec2.describe_internet_gateways()\n    for igw in response['InternetGateways']:\n        if igw['Attachments']:\n            for attachment in igw['Attachments']:\n                ec2.detach_internet_gateway(InternetGatewayId=igw['InternetGatewayId'], VpcId=attachment['VpcId'])\n                print(f\"Detached IGW {igw['InternetGatewayId']} from VPC {attachment['VpcId']}\")\n        ec2.delete_internet_gateway(InternetGatewayId=igw['InternetGatewayId'])\n        print(f\"Internet Gateway {igw['InternetGatewayId']} deleted.\")\n    print(\"Internet Gateways deleted.\")\n\ndef delete_subnets():\n    print(\"Deleting subnets...\")\n    response = ec2.describe_subnets()\n    for subnet in response['Subnets']:\n        if not subnet['DefaultForAz']:\n            ec2.delete_subnet(SubnetId=subnet['SubnetId'])\n            print(f\"Subnet {subnet['SubnetId']} deleted.\")\n    print(\"Subnets deleted.\")\n\ndef delete_route_tables():\n    print(\"Deleting route tables...\")\n    response = ec2.describe_route_tables()\n    for rt in response['RouteTables']:\n        if not rt.get('Associations') or not any(assoc.get('Main') for assoc in rt.get('Associations')):\n            ec2.delete_route_table(RouteTableId=rt['RouteTableId'])\n            print(f\"Route table {rt['RouteTableId']} deleted.\")\n    print(\"Route tables deleted.\")\n\ndef delete_vpc():\n    print(\"Deleting VPCs...\")\n    response = ec2.describe_vpcs()\n    for vpc in response['Vpcs']:\n        if not vpc['IsDefault']:\n            try:\n                print(f\"Attempting to delete VPC {vpc['VpcId']}...\")\n                ec2.delete_vpc(VpcId=vpc['VpcId'])\n                wait_for_deletion('VPC', vpc['VpcId'], \n                                  lambda id: not bool(ec2.describe_vpcs(VpcIds=[id])['Vpcs']),\n                                  error_codes=['InvalidVpcID.NotFound'])\n            except botocore.exceptions.ClientError as e:\n                print(f\"Error deleting VPC {vpc['VpcId']}: {e}\")\n    print(\"VPC deletion completed.\")\n\ndef delete_lambda_function():\n    print(\"Deleting Lambda functions...\")\n    lambda_functions = lambda_client.list_functions()\n    for function in lambda_functions['Functions']:\n        lambda_client.delete_function(FunctionName=function['FunctionName'])\n        print(f\"Lambda function {function['FunctionName']} deleted.\")\n    print(\"Lambda functions deleted.\")\n\ndef delete_nat_gateway():\n    print(\"Deleting NAT Gateways...\")\n    response = ec2.describe_nat_gateways()\n\n    for nat_gateway in response['NatGateways']:\n        nat_gateway_id = nat_gateway['NatGatewayId']\n\n        # Initiate deletion\n        ec2.delete_nat_gateway(NatGatewayId=nat_gateway_id)\n        print(f\"Initiated deletion of NAT Gateway {nat_gateway_id}...\")\n\n        # Wait for deletion to complete\n        max_attempts = 30\n        for attempt in range(max_attempts):\n            try:\n                response = ec2.describe_nat_gateways(NatGatewayIds=[nat_gateway_id])\n                if not response['NatGateways']:  # If NAT Gateway is completely gone\n                    print(f\"NAT Gateway {nat_gateway_id} is fully deleted.\")\n                    break\n\n                state = response['NatGateways'][0]['State']\n                if state == 'deleted':\n                    print(f\"NAT Gateway {nat_gateway_id} is marked as deleted.\")\n                    break  # Exit loop once it's deleted\n\n                print(f\"NAT Gateway {nat_gateway_id} is still in state '{state}'. Waiting...\")\n                time.sleep(10)\n\n            except botocore.exceptions.ClientError as e:\n                if e.response['Error']['Code'] == 'NatGatewayNotFound':\n                    print(f\"NAT Gateway {nat_gateway_id} is no longer found. Fully deleted.\")\n                    break  # Exit loop if NAT Gateway is completely removed\n                else:\n                    print(f\"Error checking NAT Gateway {nat_gateway_id}: {e}\")\n                    break\n\n    # Release Elastic IPs\n    response = ec2.describe_addresses()\n    for eip in response['Addresses']:\n        if 'AssociationId' not in eip:\n            ec2.release_address(AllocationId=eip['AllocationId'])\n            print(f\"Elastic IP {eip['AllocationId']} released.\")\n\n    print(\"NAT Gateways deleted and Elastic IPs released.\")\n\ndef delete_api_gateway():\n    print(\"Deleting API Gateway...\")\n\n    try:\n        apis = apigateway.get_rest_apis()\n    except botocore.exceptions.ClientError as e:\n        if e.response['Error']['Code'] == 'NotFoundException':\n            print(\"No API Gateways found.\")\n            return\n        else:\n            print(f\"Error retrieving API Gateways: {e}\")\n            return\n\n    for api in apis.get('items', []):\n        api_id = api['id']\n        retries = 5  # Max retries\n        for attempt in range(retries):\n            try:\n                apigateway.delete_rest_api(restApiId=api_id)\n                print(f\"API Gateway {api_id} deleted.\")\n                time.sleep(3)  # Short delay to avoid rate limiting\n                break  # Exit retry loop immediately after successful deletion\n            except botocore.exceptions.ClientError as e:\n                error_code = e.response['Error']['Code']\n                if error_code == 'TooManyRequestsException':\n                    wait_time = (2 ** attempt) + random.uniform(0, 1)  # Exponential backoff\n                    print(f\"Rate limit hit. Retrying in {wait_time:.2f} seconds...\")\n                    time.sleep(wait_time)\n                elif error_code == 'NotFoundException':\n                    print(f\"API Gateway {api_id} not found. Skipping.\")\n                    break  # Exit loop if the API was already deleted\n                else:\n                    print(f\"Error deleting API Gateway {api_id}: {e}\")\n                    break  # Exit loop for other errors\n\n    print(\"API Gateway deletion attempted.\")\n\ndef delete_iam_role():\n    print(\"Deleting IAM roles...\")\n\n    # Auto-detect the current SageMaker Notebook IAM role\n    sagemaker_role_name = get_current_sagemaker_role()\n\n    roles = iam.list_roles()\n    for role in roles['Roles']:\n        role_name = role['RoleName']\n\n        # Skip AWS managed roles and the SageMaker IAM role\n        if role_name.startswith(\"AWSServiceRoleFor\") or role_name == sagemaker_role_name:\n            print(f\"Skipping protected or in-use IAM role {role_name}.\")\n            continue\n\n        try:\n            # Detach policies\n            attached_policies = iam.list_attached_role_policies(RoleName=role_name)\n            for policy in attached_policies['AttachedPolicies']:\n                iam.detach_role_policy(RoleName=role_name, PolicyArn=policy['PolicyArn'])\n                print(f\"Detached policy {policy['PolicyArn']} from role {role_name}.\")\n\n            # Remove role from instance profiles\n            instance_profiles = iam.list_instance_profiles_for_role(RoleName=role_name)\n            for profile in instance_profiles['InstanceProfiles']:\n                iam.remove_role_from_instance_profile(InstanceProfileName=profile['InstanceProfileName'], RoleName=role_name)\n                print(f\"Removed role {role_name} from instance profile {profile['InstanceProfileName']}.\")\n\n            # Delete the role\n            iam.delete_role(RoleName=role_name)\n            print(f\"IAM role {role_name} deleted.\")\n\n        except botocore.exceptions.ClientError as e:\n            error_code = e.response['Error']['Code']\n            if error_code == 'NoSuchEntityException':\n                print(f\"Role {role_name} does not exist, skipping.\")\n            elif error_code == 'UnmodifiableEntityException':\n                print(f\"Role {role_name} is protected and cannot be deleted, skipping.\")\n            elif error_code == 'DeleteConflict':\n                print(f\"Role {role_name} has dependencies and cannot be deleted now.\")\n            else:\n                print(f\"Error deleting IAM role {role_name}: {e}\")\n\n    print(\"IAM roles deletion attempted.\")\n\ndef cleanup():\n    sagemaker_role_name = get_current_sagemaker_role()\n    delete_ec2_instances()\n    delete_nat_gateway()\n    delete_internet_gateway()\n    delete_subnets()\n    delete_route_tables()\n    delete_security_groups()\n    delete_vpc()\n    delete_lambda_function()\n    delete_api_gateway()\n    delete_iam_role()\n    print(\"Cleanup completed.\")\n\n# Run the cleanup\ncleanup()\n\n</code></pre> <pre><code>The SageMaker Notebook is using the IAM role: tcl-zt-stack-0201-SageMakerNotebookRole-dOjZBesh6VbA\nDeleting EC2 instances...\nEC2 instances deleted.\nDeleting NAT Gateways...\nInitiated deletion of NAT Gateway nat-0f6054636ced46034...\nNAT Gateway nat-0f6054636ced46034 is still in state 'deleting'. Waiting...\nNAT Gateway nat-0f6054636ced46034 is still in state 'deleting'. Waiting...\nNAT Gateway nat-0f6054636ced46034 is still in state 'deleting'. Waiting...\nNAT Gateway nat-0f6054636ced46034 is still in state 'deleting'. Waiting...\nNAT Gateway nat-0f6054636ced46034 is still in state 'deleting'. Waiting...\nNAT Gateway nat-0f6054636ced46034 is still in state 'deleting'. Waiting...\nNAT Gateway nat-0f6054636ced46034 is still in state 'deleting'. Waiting...\nNAT Gateway nat-0f6054636ced46034 is still in state 'deleting'. Waiting...\nNAT Gateway nat-0f6054636ced46034 is still in state 'deleting'. Waiting...\nNAT Gateway nat-0f6054636ced46034 is still in state 'deleting'. Waiting...\nNAT Gateway nat-0f6054636ced46034 is still in state 'deleting'. Waiting...\nNAT Gateway nat-0f6054636ced46034 is marked as deleted.\nInitiated deletion of NAT Gateway nat-0257fe5f1f03b86eb...\nNAT Gateway nat-0257fe5f1f03b86eb is marked as deleted.\nElastic IP eipalloc-06addccb20656ab95 released.\nNAT Gateways deleted and Elastic IPs released.\nDeleting Internet Gateways...\nDetached IGW igw-07f367544383df930 from VPC vpc-0728e735804cc4e70\nInternet Gateway igw-07f367544383df930 deleted.\nInternet Gateways deleted.\nDeleting subnets...\nSubnet subnet-0985cd89c6c75a3a8 deleted.\nSubnet subnet-05d90edb0a0491089 deleted.\nSubnets deleted.\nDeleting route tables...\nRoute table rtb-0a0fbbcf41bf03337 deleted.\nRoute table rtb-0a513037ab63a2104 deleted.\nRoute tables deleted.\nDeleting security groups...\nDeleting Network Interfaces (ENIs)...\nNetwork Interfaces deletion attempted.\nSecurity group sg-0a1806b633bc068de deleted.\nSecurity group sg-07c0dafa87d5bedc6 deleted.\nSecurity group deletion attempted.\nDeleting VPCs...\nAttempting to delete VPC vpc-0728e735804cc4e70...\nConfirming deletion of VPC vpc-0728e735804cc4e70...\nVPC vpc-0728e735804cc4e70 has been deleted.\nVPC deletion completed.\nDeleting Lambda functions...\nLambda function IdentityProviderFunction-ztst5lvzjs deleted.\nLambda functions deleted.\nDeleting API Gateway...\nAPI Gateway 7btkmuwh54 deleted.\nAPI Gateway deletion attempted.\nDeleting IAM roles...\nThe SageMaker Notebook is using the IAM role: tcl-zt-stack-0201-SageMakerNotebookRole-dOjZBesh6VbA\nSkipping protected or in-use IAM role AWSServiceRoleForAccessAnalyzer.\nSkipping protected or in-use IAM role AWSServiceRoleForAPIGateway.\nSkipping protected or in-use IAM role AWSServiceRoleForAWSCloud9.\nSkipping protected or in-use IAM role AWSServiceRoleForCloudFormationStackSetsOrgMember.\nSkipping protected or in-use IAM role AWSServiceRoleForCloudTrail.\nSkipping protected or in-use IAM role AWSServiceRoleForOrganizations.\nSkipping protected or in-use IAM role AWSServiceRoleForSSO.\nSkipping protected or in-use IAM role AWSServiceRoleForSupport.\nSkipping protected or in-use IAM role AWSServiceRoleForTrustedAdvisor.\nRole CloudTrail_CloudWatchLogs_Role has dependencies and cannot be deleted now.\nDetached policy arn:aws:iam::aws:policy/AmazonAPIGatewayAdministrator from role Feb1StackTP-SageMakerNotebookRole-LkmPmRSVBtwv.\nDetached policy arn:aws:iam::aws:policy/AmazonSSMFullAccess from role Feb1StackTP-SageMakerNotebookRole-LkmPmRSVBtwv.\nDetached policy arn:aws:iam::aws:policy/AmazonEC2FullAccess from role Feb1StackTP-SageMakerNotebookRole-LkmPmRSVBtwv.\nDetached policy arn:aws:iam::aws:policy/IAMFullAccess from role Feb1StackTP-SageMakerNotebookRole-LkmPmRSVBtwv.\nDetached policy arn:aws:iam::aws:policy/SecretsManagerReadWrite from role Feb1StackTP-SageMakerNotebookRole-LkmPmRSVBtwv.\nDetached policy arn:aws:iam::aws:policy/AmazonVPCFullAccess from role Feb1StackTP-SageMakerNotebookRole-LkmPmRSVBtwv.\nDetached policy arn:aws:iam::aws:policy/AmazonSageMakerFullAccess from role Feb1StackTP-SageMakerNotebookRole-LkmPmRSVBtwv.\nDetached policy arn:aws:iam::aws:policy/AmazonS3FullAccess from role Feb1StackTP-SageMakerNotebookRole-LkmPmRSVBtwv.\nDetached policy arn:aws:iam::aws:policy/AWSCloudFormationFullAccess from role Feb1StackTP-SageMakerNotebookRole-LkmPmRSVBtwv.\nDetached policy arn:aws:iam::aws:policy/AWSLambda_FullAccess from role Feb1StackTP-SageMakerNotebookRole-LkmPmRSVBtwv.\nRole Feb1StackTP-SageMakerNotebookRole-LkmPmRSVBtwv has dependencies and cannot be deleted now.\nDetached policy arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole from role LabLambdaExecutionRole-na1s9h99rx.\nIAM role LabLambdaExecutionRole-na1s9h99rx deleted.\nRole OrganizationAccountAccessRole has dependencies and cannot be deleted now.\nSkipping protected or in-use IAM role tcl-zt-stack-0201-SageMakerNotebookRole-dOjZBesh6VbA.\nIAM roles deletion attempted.\nCleanup completed.\n</code></pre> <pre><code>\n</code></pre>"},{"location":"lab6/zt-lab6/","title":"Implementing Continuous Verification in Zero Trust Architecture","text":""},{"location":"lab6/zt-lab6/#introduction","title":"Introduction","text":"<p>Welcome to our Zero Trust Architecture lab focusing on continuous verification! In this lab, you will implement a system that demonstrates core Zero Trust principles, with a particular emphasis on continuous verification using short-lived access tokens. This lab will help you understand the practical implementation of the \"Never Trust, Always Verify\" principle in a cloud environment.</p> <p></p>"},{"location":"lab6/zt-lab6/#lab-overview","title":"Lab Overview","text":"<p>In this lab, you will:</p> <ol> <li>Set up a simulated Identity Provider (IdP) using AWS Lambda and API Gateway</li> <li>Create a VPC with public and private subnets to simulate network segmentation</li> <li>Implement network security using Internet Gateway, NAT Gateway, and security groups</li> <li>Deploy a backend server with token-based access control in a private subnet</li> <li>Deploy a frontend server in a public subnet that authenticates users, manages tokens, and mediates access to the backend</li> <li>Implement and observe continuous verification mechanisms</li> </ol>"},{"location":"lab6/zt-lab6/#key-components","title":"Key Components","text":"<ol> <li>Identity Provider (IdP): Lambda functions for authentication and token management</li> <li>VPC: A Virtual Private Cloud with public and private subnets</li> <li>Security Groups: WebServerSG and BackendServerSG to control network access</li> <li>Backend Server: An EC2 instance in the private subnet that checks for valid access tokens</li> <li>Frontend Server: An EC2 instance in the public subnet that manages user sessions and access tokens</li> </ol>"},{"location":"lab6/zt-lab6/#lab-steps","title":"Lab Steps","text":"<ol> <li>Set up the AWS environment and initialize necessary clients</li> <li>Create an Identity Provider using Lambda and API Gateway</li> <li>Set up a VPC with public and private subnets</li> <li>Configure Internet Gateway, NAT Gateway, and route tables</li> <li>Create security groups for frontend and backend servers</li> <li>Deploy the backend server in the private subnet</li> <li>Deploy the frontend server in the public subnet</li> <li>Test the Zero Trust-secured system with continuous verification (admin/password123)</li> </ol>"},{"location":"lab6/zt-lab6/#key-learning-points","title":"Key Learning Points","text":"<ol> <li> <p>Never Trust, Always Verify: The frontend server authenticates with the IdP for every user action, demonstrating the core Zero Trust principle.</p> </li> <li> <p>Token-based Authentication: When a user logs in to the frontend to access the backend, it contacts the IdP to authenticate the user and obtain a token. This token is then used for subsequent requests.</p> </li> <li> <p>Continuous Verification: The lab implements short-lived tokens that require frequent renewal. You'll be able to observe:</p> </li> <li>The token expiration countdown</li> <li>Automatic token refresh when \"auto refresh\" is enabled</li> <li> <p>Session termination when the token expires without refresh</p> </li> <li> <p>Network Segmentation: The use of public and private subnets demonstrates the principle of least privilege access.</p> </li> <li> <p>Simulated Adaptive Authentication: While not fully implemented in this lab, we discuss how abnormal user activity could trigger additional authentication factors (e.g., MFA) in a production environment.</p> </li> <li> <p>Secure Communication: All communication between components uses HTTPS, ensuring data in transit is protected.</p> </li> <li> <p>Logging and Monitoring: The lab includes basic logging of authentication attempts and token refreshes, highlighting the importance of visibility in a Zero Trust model.</p> </li> </ol> <p></p>"},{"location":"lab6/zt-lab6/#lab-workflow","title":"Lab Workflow","text":"<ol> <li>Initial Authentication:</li> <li>User attempts to access the frontend server</li> <li>Frontend redirects to the IdP for authentication</li> <li> <p>Upon successful authentication, IdP issues a short-lived token</p> </li> <li> <p>Accessing Protected Resources:</p> </li> <li>Frontend uses the token to request data from the backend</li> <li> <p>Backend validates the token with the IdP before responding</p> </li> <li> <p>Continuous Verification:</p> </li> <li>Observer the token expiration countdown on the frontend</li> <li> <p>Experience automatic token refresh (when enabled) or session termination</p> </li> <li> <p>Simulated Security Events:</p> </li> <li>Manually expire the token to simulate a security event</li> <li>Observe how the system requires re-authentication</li> </ol> <p>By completing this lab, you'll gain hands-on experience with implementing and managing a Zero Trust Architecture, with a focus on the critical aspect of continuous verification. You'll see firsthand how this model enhances security by never assuming trust and constantly verifying the authenticity and authorization of users and systems.</p> <p>Let's begin by setting up our AWS environment!</p> <p></p>"},{"location":"lab6/zt-lab6/#environment-setup","title":"Environment Setup","text":"<p>This section sets up the necessary AWS environment for our Zero Trust lab.</p> <pre><code>import boto3\nimport json\nimport time\nimport random\nimport string\n\n# Set the AWS region\nregion = 'us-west-2'\n\n# Initialize AWS clients\nlambda_client = boto3.client('lambda', region_name=region)\napigateway_client = boto3.client('apigateway', region_name=region)\nec2_client = boto3.client('ec2', region_name=region)\nec2_resource = boto3.resource('ec2', region_name=region)\niam_client = boto3.client('iam', region_name=region)\n\nprint(f\"AWS environment initialized in region: {region}\")\n\n# Function to generate a random string\ndef generate_random_string(length=10):\n    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))\n\n# Initialize a global value store\nclass ValueStore:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super(ValueStore, cls).__new__(cls)\n            cls._instance.store = {}\n        return cls._instance\n\n    def set(self, key, value):\n        self.store[key] = value\n\n    def get(self, key, default=None):\n        return self.store.get(key, default)\n\n    def print_all(self):\n        for key, value in self.store.items():\n            print(f\"{key}: {value}\")\n\nvalue_store = ValueStore()\n\n# Test the ValueStore\nvalue_store.set('test_key', 'test_value')\nprint(value_store.get('test_key'))  # Should print: test_value\n\n</code></pre>"},{"location":"lab6/zt-lab6/#identity-provider-setup","title":"Identity Provider Setup","text":"<p>This section sets up a simulated Identity Provider using AWS Lambda and API Gateway.</p> <pre><code>import io\nimport zipfile\nimport subprocess\nimport sys\nimport os\n\nimport boto3\n\nsts_client = boto3.client('sts')\naccount_id = sts_client.get_caller_identity()['Account']\n\ndef create_lambda_zip(code):\n    zip_output = io.BytesIO()\n\n    with zipfile.ZipFile(zip_output, 'w', zipfile.ZIP_DEFLATED) as zip_file:\n        # Add the lambda function code to the ZIP file\n        zip_file.writestr('lambda_function.py', code)\n\n        # Install PyJWT to a temporary directory with --upgrade option\n        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"PyJWT\", \"-t\", \"/tmp/python\", \"--upgrade\"])\n\n        # Add PyJWT to the ZIP file\n        for root, dirs, files in os.walk(\"/tmp/python\"):\n            for file in files:\n                zip_file.write(os.path.join(root, file), \n                               os.path.relpath(os.path.join(root, file), \"/tmp/python\"))\n\n    return zip_output.getvalue()\n\n\n\n# Create IAM Role for Lambda\nprint(\"Creating IAM Role...\")\nassume_role_policy = {\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [{\n        \"Effect\": \"Allow\",\n        \"Principal\": {\"Service\": \"lambda.amazonaws.com\"},\n        \"Action\": \"sts:AssumeRole\"\n    }]\n}\n\nrole_name = f'LabLambdaExecutionRole-{generate_random_string()}'\nrole_response = iam_client.create_role(\n    RoleName=role_name,\n    AssumeRolePolicyDocument=json.dumps(assume_role_policy)\n)\n\niam_client.attach_role_policy(\n    RoleName=role_name,\n    PolicyArn='arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'\n)\n\n# Wait for role to be created\ntime.sleep(10)\nprint(f\"IAM Role created: {role_response['Role']['Arn']}\")\n\n# Create Lambda Function for Authentication\nprint(\"Creating Authentication Lambda Function...\")\nauth_lambda_code = '''\nimport json\nimport os\nimport time\nimport jwt\n\nSECRET_KEY = os.environ['JWT_SECRET']\nVALID_USERNAME = os.environ['LAB_USERNAME']\nVALID_PASSWORD = os.environ['LAB_PASSWORD']\n\ndef lambda_handler(event, context):\n    body = json.loads(event['body'])\n    username = body.get('username')\n    password = body.get('password')\n\n    if username == VALID_USERNAME and password == VALID_PASSWORD:\n        session_token = jwt.encode({\n            'username': username,\n            'exp': int(time.time()) + 120  # 2-minute expiration\n        }, SECRET_KEY, algorithm='HS256')\n\n        return {\n            'statusCode': 200,\n            'body': json.dumps({'token': session_token})\n        }\n    else:\n        return {\n            'statusCode': 401,\n            'body': json.dumps('Invalid username or password')\n        }\n'''\n\nauth_lambda_zip = create_lambda_zip(auth_lambda_code)\nauth_lambda_function_name = f'AuthFunction-{generate_random_string()}'\nauth_lambda_response = lambda_client.create_function(\n    FunctionName=auth_lambda_function_name,\n    Runtime='python3.8',\n    Role=role_response['Role']['Arn'],\n    Handler='lambda_function.lambda_handler',\n    Code={'ZipFile': auth_lambda_zip},\n    Timeout=30,\n    Environment={\n        'Variables': {\n            'JWT_SECRET': 'your-secret-key',\n            'LAB_USERNAME': 'admin',\n            'LAB_PASSWORD': 'password123'\n        }\n    }\n)\n\nprint(f\"Authentication Lambda Function created: {auth_lambda_response['FunctionArn']}\")\n\n# Create Lambda Function for Access Token Generation\nprint(\"Creating Access Token Lambda Function...\")\naccess_token_lambda_code = '''\nimport json\nimport os\nimport time\nimport jwt\n\nSECRET_KEY = os.environ['JWT_SECRET']\n\ndef lambda_handler(event, context):\n    auth_header = event['headers'].get('Authorization')\n    if not auth_header:\n        return {\n            'statusCode': 401,\n            'body': json.dumps('No token provided')\n        }\n\n    try:\n        session_token = jwt.decode(auth_header, SECRET_KEY, algorithms=['HS256'])\n        access_token = jwt.encode({\n            'username': session_token['username'],\n            'exp': int(time.time()) + 300  # 5 minutes expiration\n        }, SECRET_KEY, algorithm='HS256')\n\n        return {\n            'statusCode': 200,\n            'body': json.dumps({'access_token': access_token})\n        }\n    except jwt.ExpiredSignatureError:\n        return {\n            'statusCode': 401,\n            'body': json.dumps('Token expired')\n        }\n    except jwt.InvalidTokenError:\n        return {\n            'statusCode': 401,\n            'body': json.dumps('Invalid token')\n        }\n'''\n\naccess_token_lambda_zip = create_lambda_zip(access_token_lambda_code)\naccess_token_lambda_function_name = f'AccessTokenFunction-{generate_random_string()}'\naccess_token_lambda_response = lambda_client.create_function(\n    FunctionName=access_token_lambda_function_name,\n    Runtime='python3.8',\n    Role=role_response['Role']['Arn'],\n    Handler='lambda_function.lambda_handler',\n    Code={'ZipFile': access_token_lambda_zip},\n    Timeout=30,\n    Environment={\n        'Variables': {\n            'JWT_SECRET': 'your-secret-key'\n        }\n    }\n)\n\nprint(f\"Access Token Lambda Function created: {access_token_lambda_response['FunctionArn']}\")\n\n# Create API Gateway\nprint(\"Creating API Gateway...\")\napi_response = apigateway_client.create_rest_api(\n    name='ZeroTrustIdP'\n)\n\nresources = apigateway_client.get_resources(restApiId=api_response['id'])\nroot_id = resources['items'][0]['id']\n\n# Create /auth resource and method\nauth_resource = apigateway_client.create_resource(\n    restApiId=api_response['id'],\n    parentId=root_id,\n    pathPart='auth'\n)\n\napigateway_client.put_method(\n    restApiId=api_response['id'],\n    resourceId=auth_resource['id'],\n    httpMethod='POST',\n    authorizationType='NONE'\n)\n\napigateway_client.put_integration(\n    restApiId=api_response['id'],\n    resourceId=auth_resource['id'],\n    httpMethod='POST',\n    type='AWS_PROXY',\n    integrationHttpMethod='POST',\n    uri=f\"arn:aws:apigateway:{region}:lambda:path/2015-03-31/functions/{auth_lambda_response['FunctionArn']}/invocations\"\n)\n\n# Create /token resource and method\ntoken_resource = apigateway_client.create_resource(\n    restApiId=api_response['id'],\n    parentId=root_id,\n    pathPart='token'\n)\n\napigateway_client.put_method(\n    restApiId=api_response['id'],\n    resourceId=token_resource['id'],\n    httpMethod='POST',\n    authorizationType='NONE'\n)\n\napigateway_client.put_integration(\n    restApiId=api_response['id'],\n    resourceId=token_resource['id'],\n    httpMethod='POST',\n    type='AWS_PROXY',\n    integrationHttpMethod='POST',\n    uri=f\"arn:aws:apigateway:{region}:lambda:path/2015-03-31/functions/{access_token_lambda_response['FunctionArn']}/invocations\"\n)\n\n# Deploy API\nprint(\"Deploying API...\")\napigateway_client.create_deployment(\n    restApiId=api_response['id'],\n    stageName='prod'\n)\n\n# Add Lambda Permissions\nprint(\"Adding Lambda Permissions...\")\nlambda_client.add_permission(\n    FunctionName=auth_lambda_function_name,\n    StatementId='apigateway-auth-invoke',\n    Action='lambda:InvokeFunction',\n    Principal='apigateway.amazonaws.com',\n    SourceArn=f\"arn:aws:execute-api:{region}:{account_id}:{api_response['id']}/*/*/auth\"\n)\n\nlambda_client.add_permission(\n    FunctionName=access_token_lambda_function_name,\n    StatementId='apigateway-token-invoke',\n    Action='lambda:InvokeFunction',\n    Principal='apigateway.amazonaws.com',\n    SourceArn=f\"arn:aws:execute-api:{region}:{account_id}:{api_response['id']}/*/*/token\"\n)\n\n# Store the API URL for later use\nidp_url = f\"https://{api_response['id']}.execute-api.{region}.amazonaws.com/prod\"\nvalue_store.set('idp_url', idp_url)\nprint(f\"\\nIdentity Provider API URL: {idp_url}\")\n</code></pre>"},{"location":"lab6/zt-lab6/#vpc-and-network-setup","title":"VPC and Network Setup","text":"<p>This section sets up the VPC, subnets, and network components.</p> <pre><code># Create VPC\nvpc_response = ec2_client.create_vpc(CidrBlock='10.0.0.0/16')\nvpc_id = vpc_response['Vpc']['VpcId']\nec2_client.create_tags(Resources=[vpc_id], Tags=[{'Key': 'Name', 'Value': 'ZTSecuredVPC'}])\nvalue_store.set('vpc_id', vpc_id)\nprint(f\"VPC created with ID: {vpc_id}\")\n\n# Create Subnets, Internet Gateway, NAT Gateway, and Route Tables\n# [Include the code for creating subnets, gateways, and route tables here]\n# Create Subnets\naz = ec2_client.describe_availability_zones()['AvailabilityZones'][0]['ZoneName']\n\ntry:\n    public_subnet = ec2_client.create_subnet(\n        VpcId=vpc_id,\n        CidrBlock='10.0.1.0/24',\n        AvailabilityZone=az\n    )\n    public_subnet_id = public_subnet['Subnet']['SubnetId']\n    ec2_client.create_tags(Resources=[public_subnet_id], Tags=[{'Key': 'Name', 'Value': 'PublicSubnet'}])\n    print(f\"Public Subnet created with ID: {public_subnet_id}\")\nexcept ec2_client.exceptions.ClientError as e:\n    if e.response['Error']['Code'] == 'InvalidSubnet.Conflict':\n        print(\"Public Subnet already exists. Using existing subnet.\")\n        public_subnet = ec2_client.describe_subnets(\n            Filters=[\n                {'Name': 'vpc-id', 'Values': [vpc_id]},\n                {'Name': 'cidr-block', 'Values': ['10.0.1.0/24']}\n            ]\n        )['Subnets'][0]\n        public_subnet_id = public_subnet['SubnetId']\n    else:\n        raise e\n\ntry:\n    private_subnet = ec2_client.create_subnet(\n        VpcId=vpc_id,\n        CidrBlock='10.0.2.0/24',\n        AvailabilityZone=az\n    )\n    private_subnet_id = private_subnet['Subnet']['SubnetId']\n    ec2_client.create_tags(Resources=[private_subnet_id], Tags=[{'Key': 'Name', 'Value': 'PrivateSubnet'}])\n    print(f\"Private Subnet created with ID: {private_subnet_id}\")\nexcept ec2_client.exceptions.ClientError as e:\n    if e.response['Error']['Code'] == 'InvalidSubnet.Conflict':\n        print(\"Private Subnet already exists. Using existing subnet.\")\n        private_subnet = ec2_client.describe_subnets(\n            Filters=[\n                {'Name': 'vpc-id', 'Values': [vpc_id]},\n                {'Name': 'cidr-block', 'Values': ['10.0.2.0/24']}\n            ]\n        )['Subnets'][0]\n        private_subnet_id = private_subnet['SubnetId']\n    else:\n        raise e\n\n# Store subnet IDs for later use\nvalue_store.set('public_subnet_id', public_subnet_id)\nvalue_store.set('private_subnet_id', private_subnet_id)\n\nprint(f\"Public Subnet created with ID: {public_subnet_id}\")\nprint(f\"Private Subnet created with ID: {private_subnet_id}\")  # Fixed this line\n\n# Create and attach Internet Gateway\nigw = ec2_client.create_internet_gateway()\nigw_id = igw['InternetGateway']['InternetGatewayId']\nec2_client.attach_internet_gateway(InternetGatewayId=igw_id, VpcId=vpc_id)\nprint(f\"Internet Gateway created and attached with ID: {igw_id}\")\n\n# Create and configure route tables\npublic_rt = ec2_client.create_route_table(VpcId=vpc_id)\npublic_rt_id = public_rt['RouteTable']['RouteTableId']\nec2_client.create_route(\n    RouteTableId=public_rt_id,\n    DestinationCidrBlock='0.0.0.0/0',\n    GatewayId=igw_id\n)\nec2_client.associate_route_table(RouteTableId=public_rt_id, SubnetId=public_subnet_id)\nprint(f\"Public Route Table created and configured with ID: {public_rt_id}\")\n\n# Create NAT Gateway\neip = ec2_client.allocate_address(Domain='vpc')\nnat_gateway = ec2_client.create_nat_gateway(\n    AllocationId=eip['AllocationId'],\n    SubnetId=public_subnet_id\n)\nvalue_store.set('eip_allocation_id', eip['AllocationId'])\nnat_gateway_id = nat_gateway['NatGateway']['NatGatewayId']\n\n\n# Wait for NAT Gateway to be available\nprint(\"Waiting for NAT Gateway to be available...\")\nwaiter = ec2_client.get_waiter('nat_gateway_available')\nwaiter.wait(NatGatewayIds=[nat_gateway_id])\nprint(f\"NAT Gateway created with ID: {nat_gateway_id}\")\nvalue_store.set('nat_gateway_id', nat_gateway_id)\n\n\n# Create and configure private route table\nprivate_rt = ec2_client.create_route_table(VpcId=vpc_id)\nprivate_rt_id = private_rt['RouteTable']['RouteTableId']\nec2_client.create_route(\n    RouteTableId=private_rt_id,\n    DestinationCidrBlock='0.0.0.0/0',\n    NatGatewayId=nat_gateway_id\n)\nec2_client.associate_route_table(RouteTableId=private_rt_id, SubnetId=private_subnet_id)\nprint(f\"Private Route Table created and configured with ID: {private_rt_id}\")\n\n\n\n# Create Security Groups\n# [Include the code for creating security groups here]\n# Create Security Groups\nweb_sg = ec2_client.create_security_group(\n    GroupName='WebServerSG',\n    Description='Security group for web server',\n    VpcId=vpc_id\n)\nweb_sg_id = web_sg['GroupId']\nec2_client.authorize_security_group_ingress(\n    GroupId=web_sg_id,\n    IpPermissions=[\n        {'IpProtocol': 'tcp', 'FromPort': 80, 'ToPort': 80, 'IpRanges': [{'CidrIp': '0.0.0.0/0'}]},\n        {'IpProtocol': 'tcp', 'FromPort': 22, 'ToPort': 22, 'IpRanges': [{'CidrIp': '0.0.0.0/0'}]}\n    ]\n)\n\nbackend_sg = ec2_client.create_security_group(\n    GroupName='BackendServerSG',\n    Description='Security group for backend server',\n    VpcId=vpc_id\n)\nbackend_sg_id = backend_sg['GroupId']\nec2_client.authorize_security_group_ingress(\n    GroupId=backend_sg_id,\n    IpPermissions=[\n        {'IpProtocol': 'tcp', 'FromPort': 80, 'ToPort': 80, 'UserIdGroupPairs': [{'GroupId': web_sg_id}]},\n        {'IpProtocol': 'tcp', 'FromPort': 22, 'ToPort': 22, 'UserIdGroupPairs': [{'GroupId': web_sg_id}]}\n    ]\n)\n\nprint(f\"Web Server Security Group created with ID: {web_sg_id}\")\nprint(f\"Backend Server Security Group created with ID: {backend_sg_id}\")\n\n# Store security group IDs\nvalue_store.set('web_sg_id', web_sg_id)\nvalue_store.set('backend_sg_id', backend_sg_id)\n\n</code></pre>"},{"location":"lab6/zt-lab6/#deploy-fe-and-be-servers","title":"Deploy FE and BE Servers","text":"<pre><code># Deploy Backend Server\n\nimport time\n\ndef wait_for_both_instances(backend_id, frontend_id, ec2_client, retries=10, delay=30):\n    \"\"\"\n    Wait for both backend and frontend EC2 instances to pass system and instance status checks.\n\n    Parameters:\n    - backend_id: The ID of the backend EC2 instance.\n    - frontend_id: The ID of the frontend EC2 instance.\n    - ec2_client: The EC2 client to use for the status checks.\n    - retries: Number of retries before giving up (default: 10).\n    - delay: Delay between each retry in seconds (default: 30).\n\n    Returns:\n    - True if both instances pass status checks, False otherwise.\n    \"\"\"\n    print(f\"Waiting for both Backend (ID: {backend_id}) and Frontend (ID: {frontend_id}) to pass status checks...\")\n\n    for attempt in range(retries):\n        all_passed = True\n\n        for instance_id, instance_name in [(backend_id, 'Backend'), (frontend_id, 'Frontend')]:\n            response = ec2_client.describe_instance_status(InstanceIds=[instance_id])\n\n            if len(response['InstanceStatuses']) &gt; 0:\n                instance_status = response['InstanceStatuses'][0]\n                system_status = instance_status['SystemStatus']['Status']\n                instance_state = instance_status['InstanceStatus']['Status']\n\n                if system_status != 'ok' or instance_state != 'ok':\n                    all_passed = False\n                    print(f\"{instance_name} instance (ID: {instance_id}) status check not yet passed. System status: {system_status}, Instance status: {instance_state}\")\n            else:\n                all_passed = False\n                print(f\"No status available for {instance_name} instance (ID: {instance_id}). Waiting...\")\n\n        if all_passed:\n            print(f\"Both Backend (ID: {backend_id}) and Frontend (ID: {frontend_id}) passed status checks.\")\n            return True\n\n        time.sleep(delay)\n\n    print(f\"Backend and/or Frontend instances did not pass status checks after {retries} attempts.\")\n    return False\n\n\ndef get_latest_amazon_linux_2_ami():\n    response = ec2_client.describe_images(\n        Owners=['amazon'],\n        Filters=[\n            {'Name': 'name', 'Values': ['amzn2-ami-hvm-*-x86_64-gp2']},\n            {'Name': 'state', 'Values': ['available']}\n        ]\n    )\n\n    # Sort the images by creation date\n    images = sorted(response['Images'], key=lambda x: x['CreationDate'], reverse=True)\n    return images[0]['ImageId']\n\n# Get the latest Amazon Linux 2 AMI ID\nami_id = get_latest_amazon_linux_2_ami()\nprint(f\"Using AMI ID: {ami_id}\")\n\nprint(\"Deploying Backend Server...\")\nbackend_user_data = f'''#!/bin/bash\nyum update -y\nyum install -y httpd php php-json\nsystemctl start httpd\nsystemctl enable httpd\n\ncat &lt;&lt;EOT &gt; /var/www/html/index.php\n&lt;?php\nheader('Content-Type: application/json');\n\\$headers = getallheaders();\nif (!isset(\\$headers['Authorization'])) {{\n  http_response_code(401);\n  echo json_encode(['error' =&gt; 'No token provided']);\n  exit;\n}}\n\\$token = \\$headers['Authorization'];\ntry {{\n  \\$decoded = json_decode(base64_decode(str_replace('_', '/', str_replace('-','+',explode('.', \\$token)[1]))));\n  if (\\$decoded-&gt;exp &lt; time()) {{\n    throw new Exception('Token expired');\n  }}\n  echo json_encode(['sensitive' =&gt; 'This is sensitive data from the backend', 'user' =&gt; \\$decoded-&gt;username]);\n}} catch (Exception \\$e) {{\n  http_response_code(401);\n  echo json_encode(['error' =&gt; \\$e-&gt;getMessage()]);\n}}\n?&gt;\nEOT\n\nchown apache:apache /var/www/html/index.php\nchmod 644 /var/www/html/index.php\nsystemctl restart httpd\n'''\n\nbackend_instance = ec2_resource.create_instances(\n    ImageId=ami_id,  # Use the latest Amazon Linux 2 AMI\n    InstanceType='t2.micro',\n    MaxCount=1,\n    MinCount=1,\n    NetworkInterfaces=[{\n        'SubnetId': private_subnet_id,\n        'DeviceIndex': 0,\n        'AssociatePublicIpAddress': False,\n        'Groups': [backend_sg_id]\n    }],\n    UserData=backend_user_data,\n    TagSpecifications=[\n        {\n            'ResourceType': 'instance',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': 'BackendServer'\n                },\n            ]\n        },\n    ]\n)\nbackend_id = backend_instance[0].id\nprint(f\"Backend server deployed with ID: {backend_id}\")\n\n# Wait for the instance to be running\nbackend_instance[0].wait_until_running()\nbackend_instance[0].reload()\n\nbackend_private_ip = backend_instance[0].private_ip_address\nvalue_store.set('backend_private_ip', backend_private_ip)\nprint(f\"Backend server private IP: {backend_private_ip}\")\n\n\n# Deploy Frontend Web Server\nfrontend_user_data = f'''#!/bin/bash\nyum update -y\nyum install -y httpd php php-curl\nsystemctl start httpd\nsystemctl enable httpd\n\ncat &lt;&lt;EOT &gt; /var/www/html/index.php\n&lt;?php\nerror_reporting(E_ALL);\nini_set('display_errors', 1);\nini_set('log_errors', 1);\nini_set('error_log', '/var/log/httpd/php_errors.log');\n\nsession_start();\n\n\\$identity_provider_url = '{value_store.get('idp_url')}';\n\\$backend_ip = '{value_store.get('backend_private_ip')}';\n\\$error_message = '';\n\\$token_expiration = null;  // Initialize the variable\n\nerror_log(\"Script started\");\nerror_log(\"Identity Provider URL: \" . \\$identity_provider_url);\nerror_log(\"Backend IP: \" . \\$backend_ip);\n\nfunction get_access_token(\\$identity_provider_url, \\$session_token) {{\n    \\$ch = curl_init(\\$identity_provider_url . '/token');\n    curl_setopt(\\$ch, CURLOPT_RETURNTRANSFER, true);\n    curl_setopt(\\$ch, CURLOPT_POST, true);\n    curl_setopt(\\$ch, CURLOPT_HTTPHEADER, [\n        \"Authorization: \\$session_token\",\n        'Content-Type: application/json'\n    ]);\n    \\$response = curl_exec(\\$ch);\n    \\$status_code = curl_getinfo(\\$ch, CURLINFO_HTTP_CODE);\n    \\$curl_error = curl_error(\\$ch);\n    curl_close(\\$ch);\n\n    error_log(\"Get access token response: \" . \\$response);\n    error_log(\"Get access token status code: \" . \\$status_code);\n    if (\\$curl_error) {{\n        error_log(\"Get access token cURL error: \" . \\$curl_error);\n    }}\n\n    if (\\$status_code === 200) {{\n        \\$result = json_decode(\\$response, true);\n        // Use isset() to handle older PHP versions\n        return isset(\\$result['access_token']) ? \\$result['access_token'] : null;\n    }}\n    return null;\n}}\n\nfunction get_token_expiration(\\$session_token) {{\n    // Decode the token (assuming JWT) to get expiration\n    \\$decoded_token = json_decode(base64_decode(str_replace('_', '/', str_replace('-','+',explode('.', \\$session_token)[1]))));\n    return isset(\\$decoded_token-&gt;exp) ? \\$decoded_token-&gt;exp : null;\n}}\n\nfunction refresh_token(\\$identity_provider_url, &amp;\\$session_token) {{\n    \\$new_token = get_access_token(\\$identity_provider_url, \\$session_token);\n    if (\\$new_token) {{\n        \\$_SESSION['session_token'] = \\$new_token;  // Update the session token with the new token\n        error_log(\"Token refreshed successfully.\");\n        return \\$new_token;\n    }}\n    return null;\n}}\n\nif (isset(\\$_GET['reset_session'])) {{\n    session_unset();\n    session_destroy();\n    header(\"Location: index.php\");\n    exit();\n}}\n\nif (isset(\\$_GET['refresh_token'])) {{\n    if (isset(\\$_SESSION['session_token'])) {{\n        \\$new_token = refresh_token(\\$identity_provider_url, \\$_SESSION['session_token']);\n        if (\\$new_token) {{\n            echo json_encode(['status' =&gt; 'success', 'token_expiration' =&gt; get_token_expiration(\\$new_token)]);\n        }} else {{\n            echo json_encode(['status' =&gt; 'failure', 'message' =&gt; 'Failed to refresh token']);\n        }}\n    }} else {{\n        echo json_encode(['status' =&gt; 'failure', 'message' =&gt; 'Session token not found']);\n    }}\n    exit();\n}}\n\nif (\\$_SERVER['REQUEST_METHOD'] === 'POST') {{\n    if (isset(\\$_POST['username']) &amp;&amp; isset(\\$_POST['password'])) {{\n        \\$ch = curl_init(\\$identity_provider_url . '/auth');\n        curl_setopt(\\$ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt(\\$ch, CURLOPT_POST, true);\n        curl_setopt(\\$ch, CURLOPT_POSTFIELDS, json_encode([\n            'username' =&gt; \\$_POST['username'],\n            'password' =&gt; \\$_POST['password']\n        ]));\n        curl_setopt(\\$ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);\n        \\$response = curl_exec(\\$ch);\n        \\$status_code = curl_getinfo(\\$ch, CURLINFO_HTTP_CODE);\n        \\$curl_error = curl_error(\\$ch);\n        curl_close(\\$ch);\n\n        error_log(\"Auth response: \" . \\$response);\n        error_log(\"Auth status code: \" . \\$status_code);\n        if (\\$curl_error) {{\n            error_log(\"Auth cURL error: \" . \\$curl_error);\n            \\$error_message = 'An error occurred during authentication. Please try again.';\n        }} else if (\\$status_code === 200) {{\n            \\$result = json_decode(\\$response, true);\n            \\$_SESSION['session_token'] = \\$result['token'];\n        }} else if (\\$status_code === 401) {{\n            \\$error_message = 'Invalid username or password. Please try again.';\n        }} else {{\n            \\$error_message = 'Unexpected error occurred during authentication. Status code: ' . \\$status_code;\n        }}\n    }} else {{\n        \\$error_message = 'Please enter both username and password.';\n    }}\n}}\n\nif (isset(\\$_SESSION['session_token'])) {{\n    \\$access_token = get_access_token(\\$identity_provider_url, \\$_SESSION['session_token']);\n    \\$token_expiration = get_token_expiration(\\$_SESSION['session_token']);\n\n    if (\\$access_token) {{\n        \\$ch = curl_init(\"http://\\$backend_ip/index.php\");\n        curl_setopt(\\$ch, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt(\\$ch, CURLOPT_HTTPHEADER, [\n            \"Authorization: \\$access_token\"\n        ]);\n        \\$response = curl_exec(\\$ch);\n        \\$status_code = curl_getinfo(\\$ch, CURLINFO_HTTP_CODE);\n        \\$curl_error = curl_error(\\$ch);\n        curl_close(\\$ch);\n\n        error_log(\"Backend response: \" . \\$response);\n        error_log(\"Backend status code: \" . \\$status_code);\n        if (\\$curl_error) {{\n            error_log(\"Backend cURL error: \" . \\$curl_error);\n        }}\n\n        if (\\$status_code === 200) {{\n            \\$data = json_decode(\\$response, true);\n            echo \"&lt;h1&gt;Welcome to our Secure Web Server!&lt;/h1&gt;\";\n            echo \"&lt;h2&gt;Data from backend:&lt;/h2&gt;\";\n            echo \"&lt;pre&gt;\" . print_r(\\$data, true) . \"&lt;/pre&gt;\";\n\n            // If token expiration is available, add the countdown timer\n            if (\\$token_expiration) {{\n                echo \"&lt;p&gt;Session expires in: &lt;span id='countdown'&gt;&lt;/span&gt;&lt;/p&gt;\";\n                echo \"&lt;label for='autoRefreshToggle'&gt;Enable Auto Refresh:&lt;/label&gt;\";\n                echo \"&lt;input type='checkbox' id='autoRefreshToggle' onclick='toggleAutoRefresh()'&gt;\";\n\n                echo \"&lt;script&gt;\n                    var expirationTime = \\$token_expiration * 1000; // Convert to milliseconds\n                    var currentTime = new Date().getTime();\n                    var timeLeft = expirationTime - currentTime;\n                    var autoRefreshEnabled = false;\n\n                    function updateCountdown() {{\n                        var minutes = Math.floor(timeLeft / (1000 * 60));\n                        var seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);\n                        document.getElementById('countdown').innerHTML = minutes + 'm ' + seconds + 's';\n                        timeLeft -= 1000;\n\n                        if (timeLeft &lt; 0) {{\n                            clearInterval(countdownInterval);\n                            document.getElementById('countdown').innerHTML = 'Session expired';\n                            window.location.href = 'index.php?reset_session=1';\n                        }}\n                    }}\n\n                    // Function to refresh the token before it expires\n                    function refreshToken() {{\n                        fetch('index.php?refresh_token=1').then(response =&gt; response.json()).then(data =&gt; {{\n                            if (data.status === 'success') {{\n                                expirationTime = data.token_expiration * 1000;\n                                timeLeft = expirationTime - new Date().getTime();\n                                updateCountdown();\n                                console.log('Token refreshed successfully');\n                            }} else {{\n                                console.error('Error refreshing token:', data.message);\n                            }}\n                        }});\n                    }}\n\n                    // Function to toggle auto-refresh based on the checkbox state\n                    function toggleAutoRefresh() {{\n                        autoRefreshEnabled = document.getElementById('autoRefreshToggle').checked;\n                    }}\n\n                    // Set intervals to update the countdown and refresh token\n                    var countdownInterval = setInterval(updateCountdown, 1000);\n\n                    // Set token refresh to 50% of the remaining time\n                    var halfTime = timeLeft / 2;\n                    if (timeLeft &gt; halfTime) {{\n                        setTimeout(refreshToken, halfTime); // Refresh at 50% of expiration time\n                    }}\n                &lt;/script&gt;\";\n            }}\n\n            // Logout Button\n            echo \"&lt;form method='GET' action='index.php'&gt;\n                    &lt;input type='hidden' name='reset_session' value='1'&gt;\n                    &lt;button type='submit'&gt;Logout&lt;/button&gt;\n                  &lt;/form&gt;\";\n\n            // Refresh Token Button\n            echo \"&lt;button onclick='refreshToken()'&gt;Refresh Token&lt;/button&gt;\";\n\n            // Reset Session Button\n            echo \"&lt;form method='GET' action='index.php'&gt;\n                    &lt;input type='hidden' name='reset_session' value='1'&gt;\n                    &lt;button type='submit'&gt;Reset Session&lt;/button&gt;\n                  &lt;/form&gt;\";\n\n        }} else {{\n            echo \"&lt;h1&gt;Error connecting to backend server&lt;/h1&gt;\";\n            echo \"&lt;p&gt;Please check the backend server configuration.&lt;/p&gt;\";\n        }}\n    }} else {{\n        echo \"&lt;h1&gt;Session expired&lt;/h1&gt;\";\n        echo \"&lt;p&gt;Please log in again.&lt;/p&gt;\";\n    }}\n}} else {{\n    echo \"&lt;h1&gt;Please Log In&lt;/h1&gt;\";\n    if (\\$error_message) {{\n        echo \"&lt;p style='color: red;'&gt;\\$error_message&lt;/p&gt;\";\n    }}\n    echo \"&lt;form method='post'&gt;\";\n    echo \"Username: &lt;input type='text' name='username'&gt;&lt;br&gt;\";\n    echo \"Password: &lt;input type='password' name='password'&gt;&lt;br&gt;\";\n    echo \"&lt;input type='submit' value='Log In'&gt;\";\n    echo \"&lt;/form&gt;\";\n}}\n?&gt;\nEOT\n\nchown apache:apache /var/www/html/index.php\nchmod 644 /var/www/html/index.php\nsystemctl restart httpd\n'''\n\n\n\n\nfrontend_instance = ec2_resource.create_instances(\n    ImageId=ami_id,\n    InstanceType='t2.micro',\n    MaxCount=1,\n    MinCount=1,\n    NetworkInterfaces=[{\n        'SubnetId': public_subnet_id,\n        'DeviceIndex': 0,\n        'AssociatePublicIpAddress': True,\n        'Groups': [web_sg_id]\n    }],\n    UserData=frontend_user_data,\n    TagSpecifications=[\n        {\n            'ResourceType': 'instance',\n            'Tags': [\n                {\n                    'Key': 'Name',\n                    'Value': 'FrontendServer'\n                },\n            ]\n        },\n    ]\n)\nfrontend_id = frontend_instance[0].id\nprint(f\"Frontend web server deployed with ID: {frontend_id}\")\n\n# Wait for the instance to be running\nfrontend_instance[0].wait_until_running()\nfrontend_instance[0].reload()\n\nfrontend_public_ip = frontend_instance[0].public_ip_address\nvalue_store.set('frontend_public_ip', frontend_public_ip)\nprint(f\"Frontend web server public IP: {frontend_public_ip}\")\n\n# For Frontend Server\n# Wait for both backend and frontend instances to pass their status checks\nif wait_for_both_instances(backend_id, frontend_id, ec2_client):\n    print(\"Both Backend and Frontend servers are now fully operational.\")\nelse:\n    print(\"Warning: One or both servers may not be fully operational.\")\n\nprint(\"\\nSetup complete!\")\nprint(f\"You can access the frontend web server at: http://{frontend_public_ip}\")\nprint(f\"\\nIdentity Provider API URL: {idp_url}\")\nprint(\"Use the following credentials to log in:\")\nprint(\"Username: admin\")\nprint(\"Password: password123\")\n</code></pre>"},{"location":"lab6/zt-lab6/#cleanup","title":"Cleanup","text":"<p>This section contains the code to clean up all the resources created during the lab.</p> <pre><code>import boto3\nimport time\nimport botocore\n\n# Initialize AWS clients\nec2 = boto3.client('ec2')\nlambda_client = boto3.client('lambda')\napigateway = boto3.client('apigateway')\niam = boto3.client('iam')\n\ndef wait_for_deletion(resource_type, resource_id, check_function):\n    print(f\"Confirming deletion of {resource_type} {resource_id}...\")\n    max_attempts = 30\n    for _ in range(max_attempts):\n        try:\n            if not check_function(resource_id):\n                print(f\"{resource_type} {resource_id} has been deleted.\")\n                return True\n        except botocore.exceptions.ClientError as e:\n            if e.response['Error']['Code'] == 'InvalidVpcID.NotFound':\n                print(f\"{resource_type} {resource_id} has been deleted.\")\n                return True\n        print(f\"{resource_type} {resource_id} is still being deleted. Waiting...\")\n        time.sleep(10)\n    print(f\"Timeout waiting for {resource_type} {resource_id} to be deleted.\")\n    return False\n\n\ndef delete_ec2_instances():\n    print(\"Deleting EC2 instances...\")\n    response = ec2.describe_instances(\n        Filters=[{'Name': 'instance-state-name', 'Values': ['pending', 'running', 'stopping', 'stopped']}]\n    )\n    instance_ids = [instance['InstanceId'] for reservation in response['Reservations'] for instance in reservation['Instances']]\n    if instance_ids:\n        ec2.terminate_instances(InstanceIds=instance_ids)\n        waiter = ec2.get_waiter('instance_terminated')\n        waiter.wait(InstanceIds=instance_ids)\n    print(\"EC2 instances deleted.\")\n\ndef delete_security_groups():\n    print(\"Deleting security groups...\")\n    response = ec2.describe_security_groups()\n    for sg in response['SecurityGroups']:\n        if sg['GroupName'] != 'default':\n            try:\n                ec2.delete_security_group(GroupId=sg['GroupId'])\n                print(f\"Security group {sg['GroupId']} deleted.\")\n            except botocore.exceptions.ClientError as e:\n                print(f\"Error deleting security group {sg['GroupId']}: {e}\")\n    print(\"Security group deletion attempted.\")\n\ndef delete_nat_gateway():\n    print(\"Deleting NAT Gateways...\")\n    response = ec2.describe_nat_gateways()\n    for nat_gateway in response['NatGateways']:\n        ec2.delete_nat_gateway(NatGatewayId=nat_gateway['NatGatewayId'])\n        wait_for_deletion('NAT Gateway', nat_gateway['NatGatewayId'], \n                          lambda id: ec2.describe_nat_gateways(NatGatewayIds=[id])['NatGateways'][0]['State'] != 'deleted')\n\n    # Release Elastic IPs\n    response = ec2.describe_addresses()\n    for eip in response['Addresses']:\n        if 'AssociationId' not in eip:\n            ec2.release_address(AllocationId=eip['AllocationId'])\n    print(\"NAT Gateways deleted and Elastic IPs released.\")\n\ndef delete_internet_gateway():\n    print(\"Deleting Internet Gateways...\")\n    response = ec2.describe_internet_gateways()\n    for igw in response['InternetGateways']:\n        if igw['Attachments']:\n            ec2.detach_internet_gateway(InternetGatewayId=igw['InternetGatewayId'], VpcId=igw['Attachments'][0]['VpcId'])\n        ec2.delete_internet_gateway(InternetGatewayId=igw['InternetGatewayId'])\n    print(\"Internet Gateways deleted.\")\n\ndef delete_subnets():\n    print(\"Deleting subnets...\")\n    response = ec2.describe_subnets()\n    for subnet in response['Subnets']:\n        if not subnet['DefaultForAz']:\n            ec2.delete_subnet(SubnetId=subnet['SubnetId'])\n    print(\"Subnets deleted.\")\n\ndef delete_route_tables():\n    print(\"Deleting route tables...\")\n    response = ec2.describe_route_tables()\n    for rt in response['RouteTables']:\n        if not rt.get('Associations') or not any(assoc.get('Main') for assoc in rt.get('Associations')):\n            ec2.delete_route_table(RouteTableId=rt['RouteTableId'])\n    print(\"Route tables deleted.\")\n\ndef delete_vpc():\n    print(\"Deleting VPCs...\")\n    response = ec2.describe_vpcs()\n    for vpc in response['Vpcs']:\n        if not vpc['IsDefault']:\n            try:\n                print(f\"Attempting to delete VPC {vpc['VpcId']}...\")\n                ec2.delete_vpc(VpcId=vpc['VpcId'])\n                wait_for_deletion('VPC', vpc['VpcId'], \n                                  lambda id: bool(ec2.describe_vpcs(VpcIds=[id])['Vpcs']))\n            except botocore.exceptions.ClientError as e:\n                if e.response['Error']['Code'] == 'InvalidVpcID.NotFound':\n                    print(f\"VPC {vpc['VpcId']} has already been deleted.\")\n                else:\n                    print(f\"Error deleting VPC {vpc['VpcId']}: {e}\")\n                    print(\"Please check and manually delete any remaining resources in this VPC.\")\n    print(\"VPC deletion completed.\")\n\n\ndef delete_lambda_function():\n    print(\"Deleting Lambda functions...\")\n    lambda_functions = lambda_client.list_functions()\n    for function in lambda_functions['Functions']:\n        if function['FunctionName'].startswith('IdentityProviderFunction-'):\n            lambda_client.delete_function(FunctionName=function['FunctionName'])\n    print(\"Lambda functions deleted.\")\n\ndef delete_api_gateway():\n    print(\"Deleting API Gateway...\")\n    apis = apigateway.get_rest_apis()\n    for api in apis['items']:\n        if api['name'] == 'IdentityProviderApi':\n            apigateway.delete_rest_api(restApiId=api['id'])\n    print(\"API Gateway deleted.\")\n\ndef delete_iam_role():\n    print(\"Deleting IAM roles...\")\n    roles = iam.list_roles()\n    for role in roles['Roles']:\n        if role['RoleName'].startswith('LabLambdaExecutionRole-'):\n            attached_policies = iam.list_attached_role_policies(RoleName=role['RoleName'])\n            for policy in attached_policies['AttachedPolicies']:\n                iam.detach_role_policy(RoleName=role['RoleName'], PolicyArn=policy['PolicyArn'])\n            iam.delete_role(RoleName=role['RoleName'])\n    print(\"IAM roles deleted.\")\n\ndef cleanup():\n    delete_ec2_instances()\n    delete_nat_gateway()\n    delete_internet_gateway()\n    delete_subnets()\n    delete_route_tables()\n    delete_security_groups()\n    delete_vpc()\n    delete_lambda_function()\n    delete_api_gateway()\n    delete_iam_role()\n    print(\"Cleanup completed.\")\n\n# Run the cleanup\ncleanup()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"lab7/zt-lab7a/","title":"Single Packet Authentication, All Drop Firewall, SDP, PDP, PEP","text":""},{"location":"lab7/zt-lab7a/#zero-trust-architecture-simulation-guide","title":"Zero Trust Architecture Simulation Guide","text":""},{"location":"lab7/zt-lab7a/#introduction","title":"Introduction","text":"<p>This interactive simulation demonstrates key concepts of Zero Trust Architecture (ZTA) in a simplified environment. By engaging with this simulation, you'll gain hands-on experience with core ZTA principles such as continuous authentication, least privilege access, and dynamic trust determination.</p> <p></p>"},{"location":"lab7/zt-lab7a/#simulation-overview","title":"Simulation Overview","text":"<p>The simulation represents a basic Zero Trust environment with the following components:</p> <ol> <li>Client: Represents the user trying to access resources.</li> <li>All-Drop Firewall: Initially blocks all access attempts.</li> <li>Software-Defined Perimeter (SDP) Controller: Manages access requests and authentication.</li> <li>Policy Decision Point (PDP): Evaluates access policies.</li> <li>Identity Provider (IdP): Handles user authentication.</li> <li>Policy Enforcement Point (PEP): Enforces access decisions.</li> <li>Backend Server: Hosts the sensitive data.</li> </ol>"},{"location":"lab7/zt-lab7a/#how-to-use-the-simulation","title":"How to Use the Simulation","text":"<ol> <li>Run the Jupyter notebook to start the simulation.</li> <li>You'll be presented with a login interface.</li> <li>After successful login, you can simulate various user behaviors and attempt to access the backend server.</li> <li>Observe how the system responds to different scenarios.</li> </ol>"},{"location":"lab7/zt-lab7a/#use-cases","title":"Use Cases","text":""},{"location":"lab7/zt-lab7a/#use-case-1-standard-login-and-access","title":"Use Case 1: Standard Login and Access","text":"<ol> <li>Login with username \"admin\" and password \"password123\".</li> <li>(If asked) MFA will be generated randomly.</li> <li>Click \"Access Backend Server\".</li> <li>Observe how the system grants access after verifying your credentials and token.</li> </ol>"},{"location":"lab7/zt-lab7a/#use-case-2-session-expiration","title":"Use Case 2: Session Expiration","text":"<ol> <li>Login as in Use Case 1.</li> <li>Click \"Simulate User Behavior\" multiple times until you see \"Session expired due to token expiration\".</li> <li>Attempt to log in again and access the backend server.</li> <li>Notice how the system requires re-authentication after session expiration.</li> </ol>"},{"location":"lab7/zt-lab7a/#use-case-3-unusual-behavior-detection-and-mfa","title":"Use Case 3: Unusual Behavior Detection and MFA","text":"<ol> <li>Login as in Use Case 1.</li> <li>Click \"Simulate User Behavior\" until you see \"Unusual behavior detected\".</li> <li>You'll be logged out and required to provide an MFA code.</li> <li>Log in again with the provided MFA code.</li> <li>Try accessing the backend server again.</li> <li>Observe how the system handles stepped-up authentication in response to unusual behavior.</li> </ol>"},{"location":"lab7/zt-lab7a/#use-case-4-failed-authentication","title":"Use Case 4: Failed Authentication","text":"<ol> <li>Attempt to login with incorrect credentials (e.g., username \"user\", password \"wrongpass\").</li> <li>Observe how the system denies access and doesn't proceed to the backend server.</li> </ol>"},{"location":"lab7/zt-lab7a/#use-case-5-logout-and-re-authentication","title":"Use Case 5: Logout and Re-authentication","text":"<ol> <li>Login successfully.</li> <li>Click the \"Logout\" button.</li> <li>Attempt to access the backend server without logging in.</li> <li>Notice how the system requires authentication for each new session.</li> </ol>"},{"location":"lab7/zt-lab7a/#key-learning-points","title":"Key Learning Points","text":"<ul> <li>Continuous authentication: The system constantly verifies the user's identity and session validity.</li> <li>Least privilege access: Access is granted only after successful authentication and policy evaluation.</li> <li>Dynamic trust: Trust is never assumed and is re-evaluated based on user behavior and session state.</li> <li>Multi-factor authentication (MFA): Additional authentication factors are required when unusual behavior is detected.</li> </ul>"},{"location":"lab7/zt-lab7a/#reflection-questions","title":"Reflection Questions","text":"<ol> <li>How does this Zero Trust approach differ from traditional perimeter-based security?</li> <li>What are the potential benefits and challenges of implementing a Zero Trust Architecture in a real-world scenario?</li> <li>How might this basic model be expanded to cover more complex scenarios in enterprise environments?</li> </ol> <p>By exploring these use cases and reflecting on the simulation, you'll gain valuable insights into the principles and operations of Zero Trust Architecture.</p> <pre><code># Import Necessary Modules\nimport random\nimport time\nfrom datetime import datetime, timedelta\nimport ipywidgets as widgets\nfrom IPython.display import display, clear_output, HTML\n\n# User session data\nuser_session = {\n    'authenticated': False,\n    'username': None,\n    'password': None,\n    'token': None,\n    'token_expiry': None,\n    'session_timeout': 300,  # 5 minutes\n    'require_mfa': False,\n    'mfa_code': None\n}\n\n# Output areas\nstatus_output = widgets.Output()\nspa_output = widgets.Output()\nlogin_output = widgets.Output()\nuser_behavior_output = widgets.Output()\n\n# Main container\napp_display = widgets.VBox([\n    status_output,\n    spa_output,\n    login_output,\n    user_behavior_output\n])\n\n# Helper Functions for Visibility Management\ndef show_output(widget):\n    widget.layout.visibility = 'visible'\n\ndef hide_output(widget):\n    widget.layout.visibility = 'hidden'\n\n# Generate Random MFA Code\ndef generate_mfa_code():\n    return ''.join([str(random.randint(0, 9)) for _ in range(6)])\n\n# Logout Function\ndef logout():\n    # Clear all outputs\n    with spa_output:\n        clear_output(wait=True)\n    with user_behavior_output:\n        clear_output(wait=True)\n    with login_output:\n        clear_output(wait=True)\n    with status_output:\n        clear_output(wait=True)\n        print(\"Logged out successfully.\")\n\n    # Reset user session\n    user_session.update({\n        'authenticated': False,\n        'username': None,\n        'password': None,\n        'token': None,\n        'token_expiry': None,\n        'require_mfa': False,\n        'mfa_code': None\n    })\n\n    # Re-display login interface\n    login_interface()\n\n# Session Termination Function\ndef session_terminated(reason, keep_require_mfa=False):\n    # Clear SPA and User Behavior Outputs\n    with spa_output:\n        clear_output(wait=True)\n    with user_behavior_output:\n        clear_output(wait=True)\n    # Reset user session except 'require_mfa' if keep_require_mfa is True\n    user_session.update({\n        'authenticated': False,\n        'username': None,\n        'password': None,\n        'token': None,\n        'token_expiry': None\n    })\n    if keep_require_mfa:\n        user_session['require_mfa'] = True\n        user_session['mfa_code'] = None  # Will be generated in login_interface\n    else:\n        user_session['require_mfa'] = False\n        user_session['mfa_code'] = None\n    # For debugging: print user_session state after termination\n    with status_output:\n        clear_output()\n        print(f\"Session terminated: {reason}\")\n    # Re-display login interface with termination message\n    login_interface(message=reason)\n\n# Login Interface\ndef login_interface(message=None, keep_message=False):\n    # Show login_output and hide user_behavior_output\n    show_output(login_output)\n    hide_output(user_behavior_output)\n\n    # Clear previous contents\n    with login_output:\n        clear_output(wait=True)\n        # Create login fields\n        username_input = widgets.Text(\n            placeholder='Enter username',\n            description='Username:',\n            disabled=False\n        )\n        password_input = widgets.Password(\n            placeholder='Enter password',\n            description='Password:',\n            disabled=False\n        )\n        display(username_input, password_input)\n\n        # If MFA is required, add MFA input and generate a new MFA code\n        if user_session['require_mfa']:\n            user_session['mfa_code'] = generate_mfa_code()  # Generate new MFA code\n            mfa_input = widgets.Text(\n                placeholder='Enter MFA code',\n                description='MFA Code:',\n                disabled=False\n            )\n            display(mfa_input)\n            display(HTML(f\"&lt;p&gt;For simulation purposes, use MFA code: {user_session['mfa_code']}&lt;/p&gt;\"))\n        else:\n            mfa_input = None\n\n        # Display login button\n        login_button = widgets.Button(description='Login', button_style='primary')\n        output = widgets.Output()\n        display(login_button, output)\n\n    # Display termination message if any\n    if message and not keep_message:\n        with status_output:\n            clear_output()\n            display(HTML(f\"&lt;span style='color:red'&gt;{message}&lt;/span&gt;\"))\n    elif not keep_message:\n        with status_output:\n            clear_output()\n\n    # Clear SPA output\n    with spa_output:\n        clear_output(wait=True)\n\n    # Define Login Button Callback\n    def on_login_button_clicked(b):\n        username = username_input.value\n        password = password_input.value\n        mfa_code = mfa_input.value if mfa_input else None\n\n        user_session['username'] = username\n        user_session['password'] = password\n        user_session['entered_mfa'] = mfa_code\n\n        with output:\n            clear_output()\n\n        # Always start with the SPA process, regardless of MFA\n        send_spa_packet()\n\n    login_button.on_click(on_login_button_clicked)\n\n# SPA Process Functions\ndef send_spa_packet():\n    with spa_output:\n        clear_output(wait=True)\n        print(\"Client: Attempting to access resource.\")\n    time.sleep(1)\n    with spa_output:\n        print(\"All-Drop Firewall: Blocking access attempt.\")\n    time.sleep(1)\n    with spa_output:\n        print(\"Client: Sending SPA packet to firewall.\")\n    time.sleep(1)\n    firewall_process_spa()\n\ndef firewall_process_spa():\n    with spa_output:\n        print(\"Firewall: SPA packet received.\")\n    time.sleep(1)\n    with spa_output:\n        print(\"Firewall: Redirecting client to PDP.\")\n    time.sleep(1)\n    pdp_evaluate_access()\n\ndef pdp_evaluate_access():\n    with spa_output:\n        print(\"PDP: Received request from firewall.\")\n    time.sleep(1)\n    with spa_output:\n        print(\"PDP: Communicating with IdP for user authentication.\")\n    time.sleep(1)\n    auth_result = idp_authenticate()\n    pdp_decide_access(auth_result)\n\n\ndef idp_authenticate():\n    with spa_output:\n        print(\"IdP: Verifying user credentials.\")\n    time.sleep(1)\n\n    username = user_session['username']\n    password = user_session['password']\n    entered_mfa = user_session['entered_mfa']\n\n    if username == 'admin' and password == 'password123':\n        if user_session['require_mfa']:\n            if entered_mfa == user_session['mfa_code']:\n                with spa_output:\n                    print(\"IdP: User authenticated successfully with MFA.\")\n                user_session['token'] = 'valid_token'\n                user_session['token_expiry'] = datetime.now() + timedelta(minutes=5)\n                return True\n            else:\n                with spa_output:\n                    print(\"IdP: MFA verification failed.\")\n                return False\n        else:\n            with spa_output:\n                print(\"IdP: User authenticated successfully.\")\n            user_session['token'] = 'valid_token'\n            user_session['token_expiry'] = datetime.now() + timedelta(minutes=5)\n            return True\n    else:\n        with spa_output:\n            print(\"IdP: User authentication failed.\")\n        return False\n\n\ndef pdp_decide_access(auth_result):\n    if auth_result:\n        with spa_output:\n            print(\"PDP: Authentication successful. Evaluating access policy.\")\n        time.sleep(1)\n        # Here you could add additional policy checks if needed\n        with spa_output:\n            print(\"PDP: Access granted. Informing PEP to open port.\")\n        time.sleep(1)\n        # Clear status_output to remove any residual messages\n        with status_output:\n            clear_output()\n        pep_open_port()\n    else:\n        with spa_output:\n            print(\"PDP: Authentication failed. Access denied.\")\n        time.sleep(1)\n        with spa_output:\n            print(\"Client: Access denied. Cannot proceed.\")\n        time.sleep(1)\n        # Display authentication failure message\n        with status_output:\n            clear_output()\n            display(HTML(\"&lt;span style='color:red'&gt;Authentication failed. Please try again.&lt;/span&gt;\"))\n        # Re-display login interface without clearing the error message\n        login_interface(keep_message=True)\n\n\ndef pep_open_port():\n    with spa_output:\n        print(\"PEP: Opening port for client.\")\n    # Transition to user behavior interface\n    user_behavior_interface()\n\ndef client_send_request():\n    with spa_output:\n        print(\"Client: Sending request to backend server.\")\n    time.sleep(1)\n    with spa_output:\n        print(\"BE Server: Verifying token.\")\n    time.sleep(1)\n    if user_session.get('token') == 'valid_token' and datetime.now() &lt; user_session.get('token_expiry', datetime.min):\n        with spa_output:\n            print(\"BE Server: Token valid. Accessing sensitive data.\")\n            print(\"\\nAccess Granted:\\nSensitive data from backend server.\")\n        with status_output:\n            clear_output()\n            print(\"Access to sensitive data granted.\")\n    else:\n        with spa_output:\n            print(\"BE Server: Invalid token. Access denied.\")\n            print(\"Client: Access denied. Cannot access backend server.\")\n        with status_output:\n            clear_output()\n            print(\"Access denied due to invalid token.\")\n\n# User Behavior Interface\ndef user_behavior_interface():\n    # Show User Behavior Output and Hide Login Output\n    show_output(user_behavior_output)\n    hide_output(login_output)\n\n    # Clear previous contents\n    with user_behavior_output:\n        clear_output(wait=True)\n        # Display user behavior buttons\n        simulate_button = widgets.Button(description='Simulate User Behavior', button_style='info')\n        access_button = widgets.Button(description='Access Backend Server', button_style='success')\n        logout_button = widgets.Button(description='Logout', button_style='danger')\n\n        # Define Button Callbacks\n        def on_simulate_button_clicked(b):\n            simulate_user_behavior()\n\n        def on_access_button_clicked(b):\n            client_send_request()\n\n        def on_logout_button_clicked(b):\n            logout()\n\n        simulate_button.on_click(on_simulate_button_clicked)\n        access_button.on_click(on_access_button_clicked)\n        logout_button.on_click(on_logout_button_clicked)\n\n        # Display Buttons Horizontally\n        display(widgets.HBox([simulate_button, access_button, logout_button]))\n\n    # Clear status_output\n    with status_output:\n        clear_output()\n    # SPA trace remains visible\n\n# User Behavior Simulation\ndef simulate_user_behavior():\n    with status_output:\n        clear_output()\n        state = random.choice(['still_valid', 'token_expired', 'unusual_behavior'])\n        if state == 'still_valid':\n            display(HTML(\"&lt;p style='color:green'&gt;Simulated user state: still_valid&lt;/p&gt;\"))\n            display(HTML(\"&lt;p style='color:green'&gt;User behavior is normal. Session continues.&lt;/p&gt;\"))\n        elif state == 'token_expired':\n            print(f\"Simulated user state: {state}\")\n            print(\"User token has expired. Please log in again.\")\n            user_session['token_expiry'] = datetime.now() - timedelta(seconds=1)\n            session_terminated(\"Session expired due to token expiration.\")\n        elif state == 'unusual_behavior':\n            print(f\"Simulated user state: {state}\")\n            print(\"Unusual behavior detected. Please log in again.\")\n            user_session.update({\n                'authenticated': False,\n                'token': None,\n                'token_expiry': None,\n                'require_mfa': True,\n                'mfa_code': None  # Set to None, will be generated in login_interface\n            })\n            session_terminated(\"Session terminated due to unusual behavior.\", keep_require_mfa=True)\n    # For debugging: print user_session after simulating behavior\n    print(f\"DEBUG: user_session after simulating behavior = {user_session}\")\n\n# Run the Lab\ndef run_lab():\n    # Initially, show login_output and hide user_behavior_output\n    show_output(login_output)\n    hide_output(user_behavior_output)\n    # Display the main container\n    display(app_display)\n    # Initialize login interface\n    login_interface()\n\nrun_lab()\n\n</code></pre> <pre><code>\n</code></pre>"},{"location":"lab7/zt-lab7b/","title":"Visual Simulation: Single Packet Authentication, All Drop Firewall, SDP, PDP, PEP","text":""},{"location":"lab7/zt-lab7b/#zero-trust-architecture-react-visualization-guide","title":"Zero Trust Architecture React Visualization Guide","text":""},{"location":"lab7/zt-lab7b/#introduction","title":"Introduction","text":"<p>This interactive React application provides a visual demonstration of Zero Trust Architecture (ZTA) principles. By engaging with this simulation, you'll gain a graphical understanding of how different components in a Zero Trust environment interact during authentication, data access processes, and various security scenarios.</p> <p></p> <p>Try the simulation here --&gt; SPA Simulation</p>"},{"location":"lab7/zt-lab7b/#visualization-overview","title":"Visualization Overview","text":"<p>The application presents a simplified Zero Trust environment with the following components:</p> <ol> <li>Client: The end-user attempting to access resources.</li> <li>Front-end: The user interface of the application.</li> <li>Firewall: Acts as the initial barrier, following the \"default deny\" principle.</li> <li>Policy Decision Point (PDP): Evaluates access policies.</li> <li>Identity Provider (IdP): Handles user authentication.</li> <li>Policy Enforcement Point (PEP): Enforces access decisions.</li> <li>Back-end: Hosts the sensitive data.</li> </ol>"},{"location":"lab7/zt-lab7b/#how-to-use-the-visualization","title":"How to Use the Visualization","text":"<ol> <li>Run the React application in your browser.</li> <li>You'll see a visual representation of the Zero Trust components and a login interface.</li> <li>Interact with the login process and observe how the system responds in different scenarios.</li> <li>Watch the animation of data flow between components based on your actions.</li> </ol>"},{"location":"lab7/zt-lab7b/#core-use-cases","title":"Core Use Cases","text":""},{"location":"lab7/zt-lab7b/#use-case-1-wrong-credentials","title":"Use Case 1: Wrong Credentials","text":"<ol> <li>Enter incorrect username and password (e.g., username: \"user\", password: \"wrongpass\").</li> <li>Click the \"Login\" button.</li> <li>Observe the authentication failure process.</li> </ol> <p>Learning Points: - How the system handles incorrect credentials. - The \"default deny\" principle in action. - The role of the IdP in credential verification.</p>"},{"location":"lab7/zt-lab7b/#use-case-2-proper-credentials","title":"Use Case 2: Proper Credentials","text":"<ol> <li>Enter the correct username \"admin\" and password \"password\".</li> <li>Click the \"Login\" button.</li> <li>Observe the successful initial authentication process.</li> </ol> <p>Learning Points: - The flow of successful credential verification. - How the system transitions to requiring additional verification (MFA).</p>"},{"location":"lab7/zt-lab7b/#use-case-3-access-backend-data-post-login","title":"Use Case 3: Access Backend Data (Post-Login)","text":"<ol> <li>After successful login from Use Case 2, attempt to access backend data.</li> <li>Observe how the system handles this request without MFA.</li> </ol> <p>Learning Points: - The principle of least privilege access. - How the system differentiates between general and sensitive data access.</p>"},{"location":"lab7/zt-lab7b/#use-case-4-logout","title":"Use Case 4: Logout","text":"<ol> <li>After being logged in, click the \"Logout\" button.</li> <li>Observe how the system handles the logout process.</li> </ol> <p>Learning Points: - Session termination in a Zero Trust environment. - How the system resets to its default secure state.</p>"},{"location":"lab7/zt-lab7b/#use-case-5-login-access-sensitive-data-wrong-mfa","title":"Use Case 5: Login, Access Sensitive Data, Wrong MFA","text":"<ol> <li>Log in with correct credentials (username: \"admin\", password: \"password\").</li> <li>Attempt to access sensitive data, triggering an MFA request.</li> <li>Enter an incorrect MFA code.</li> <li>Observe the system's response to failed MFA.</li> </ol> <p>Learning Points: - The role of Multi-Factor Authentication in Zero Trust. - How the system handles partial authentication success (correct password but failed MFA). - The importance of layered security measures.</p>"},{"location":"lab7/zt-lab7b/#use-case-6-login-access-sensitive-data-correct-mfa-access-backend-data","title":"Use Case 6: Login, Access Sensitive Data, Correct MFA, Access Backend Data","text":"<ol> <li>Log in with correct credentials (username: \"admin\", password: \"password\").</li> <li>Attempt to access sensitive data, triggering an MFA request.</li> <li>Enter the correct MFA code \"123456\".</li> <li>Observe the full authentication process.</li> <li>Access the backend data and observe the data flow.</li> </ol> <p>Learning Points: - The complete Zero Trust authentication and authorization process. - How successful MFA leads to access grant. - The flow of data from the backend to the client in a fully authenticated session.</p>"},{"location":"lab7/zt-lab7b/#reflection-questions","title":"Reflection Questions","text":"<ol> <li>How does the visualization demonstrate the \"never trust, always verify\" principle of Zero Trust Architecture?</li> <li>What are the key differences you observed in the system's behavior between failed and successful authentication attempts?</li> <li>How does the addition of MFA enhance the security of the system? Are there any potential drawbacks?</li> <li>Based on the visualization, how would you explain the roles of the Policy Decision Point (PDP) and Policy Enforcement Point (PEP)?</li> <li>How does this model demonstrate the concept of least privilege access?</li> <li>Can you think of real-world scenarios where this type of authentication flow would be particularly beneficial or challenging to implement?</li> </ol>"},{"location":"lab7/zt-lab7b/#extended-learning","title":"Extended Learning","text":"<ol> <li>Research and suggest additional authentication factors that could be incorporated into this Zero Trust model.</li> <li>Discuss how this visualization might change if it were to represent a microservices architecture instead of a monolithic back-end.</li> <li>Consider how the principles demonstrated in this visualization could be applied to other areas of cybersecurity, such as network segmentation or data encryption.</li> </ol> <p>By exploring these core use cases, reflecting on the questions, and engaging in extended learning activities, you'll develop a comprehensive understanding of Zero Trust Architecture principles and their practical application in modern cybersecurity environments.</p>"}]}